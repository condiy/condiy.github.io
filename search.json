[{"title":"二分查找","url":"https://xivier.github.io/2019/06/30/二分查找/","content":"<h1 id=\"原始二分查找\"><a href=\"#原始二分查找\" class=\"headerlink\" title=\"原始二分查找\"></a>原始二分查找</h1><blockquote>\n<p>Input : [1,2,3,4,5]<br>key : 3<br>return the index : 2</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binarySearch = <span class=\"function\">(<span class=\"params\">nums, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span>, mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt;= h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] === key) <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; key) h = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度：二分查找，每次将查找区间减半，这种折半特性的时间复杂度为 O(logN)</p>\n<p>返回值：</p>\n<ul>\n<li>-1：表示没有查找到 key。</li>\n<li>l：表示插入到 nums 中的正确位置。</li>\n</ul>\n<p>变种：</p>\n<p>二分查找有很多变种，变种要注意边界值的判断。例如在一个有重复元素中的数组中查找最左边的 key 值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binarySearch = <span class=\"function\">(<span class=\"params\">nums, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span>, mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key &lt;= nums[mid]) h = mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和上述的实现有什么不同呢？</p>\n<ul>\n<li>赋值表达式变成了 h = mid</li>\n<li>循环语句变成了 l &lt; h</li>\n<li>最后返回的是 l</li>\n</ul>\n<p>因为要找最左的值，所以设置 key &lt;= nums[mid] 时，最左的区间位于 [l,mid] 中，此时将 h = mid，因为 mid 所在的位置也可以是解。</p>\n<p>如果要找最右的值，应当设置 key &gt;= nums[mid] 时，最右的区间位于 [mid,h] 中，此时将 l = mid，因为 mid 所在的位置也可以是解。</p>\n<p>在 h = m 情况下，如果循环条件为 l &lt;= h，那么有可能会出现无限循环无法退出的情况。</p>\n<h1 id=\"求开方\"><a href=\"#求开方\" class=\"headerlink\" title=\"求开方\"></a>求开方</h1><blockquote>\n<p>LeetCode 69</p>\n<p>Input: 4<br>Output: 2<br>Input: 8<br>Output: 2</p>\n<p>如果开方开不尽，开方结果向下取整。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mySqrt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">1</span>, h = x</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt;= h) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sqrt = <span class=\"built_in\">Math</span>.floor(x / mid)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sqrt === mid) <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sqrt &lt; mid) h = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>通过二分查找来查找开方数 sqrt，因为 sqrt * sqrt = x。所以可以对 1 -  x 的区间进行二分查找。</p>\n<p>本题关键是最后的返回值，退出循环时， l &gt; h，当开方开不尽的时候，结果就是 h ，为什么是 h 不是 l 呢？循环退出时， h 总是比 l 小1，由于本题要向下取整，所以取 h。</p>\n<h1 id=\"大于给定元素的最小元素\"><a href=\"#大于给定元素的最小元素\" class=\"headerlink\" title=\"大于给定元素的最小元素\"></a>大于给定元素的最小元素</h1><blockquote>\n<p>LeetCode 744</p>\n<p>Input:<br>letters = [“c”, “f”, “j”]<br>target = “d”<br>Output: “f”<br>Input:<br>letters = [“c”, “f”, “j”]<br>target = “k”<br>Output: “c”</p>\n<p>题目描述：给定一个有序的字符数组 letters，再给定一个字符 target，要求在 letters 中查找大于 target 的最小字符。如果找不到就返回第一个元素。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nextGreatestLetter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">letters, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = letters.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt;= h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (letters[mid] &lt;= target) &#123;</span><br><span class=\"line\">      l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      h = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l &lt; letters.length ? letters[l] : letters[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于字符数组是有序的，根据有序数组查找指定字符，想到用二分查找。</p>\n<h1 id=\"有序数组的-Single-Element\"><a href=\"#有序数组的-Single-Element\" class=\"headerlink\" title=\"有序数组的 Single Element\"></a>有序数组的 Single Element</h1><blockquote>\n<p>LeetCode 540</p>\n<p>Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]<br>Output: 2</p>\n<p>一个有序数组只有一个数不出现两次，找出这个数</p>\n</blockquote>\n<p>时间复杂度要求 O(logN)，因此很容易想到用二分查找。</p>\n<p>假设index 为 Single Element 出现在数组中的位置。在 index 之后，数组原来的下标状态将会改变。如果 m 为偶数， m+1 &lt; index，那么，nums[m] = nums[m+1]；m+1 &gt;=index，那么 nums[m] != nums[m+1]</p>\n<p>所以可知， 如果 nums[m] === nums[m+1] 则 target 所在的区间为 [m+2,h]；如果 nums[m] !=== nums[m+1] 则 target 所在区间为 [l,m]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> singleNonDuplicate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span>, mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mid % <span class=\"number\">2</span> === <span class=\"number\">1</span>) mid -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] === nums[mid + <span class=\"number\">1</span>]) l = mid + <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> h = mid</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums[h]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第一个错误的版本\"><a href=\"#第一个错误的版本\" class=\"headerlink\" title=\"第一个错误的版本\"></a>第一个错误的版本</h1><blockquote>\n<p>LeetCode 278</p>\n<p>题目描述：找到一个错误版本。</p>\n<p>如果第 mid 个版本出错，那么第一个错误版本所在区间为 [l,mid]，此时 h=mid；否认第一个错误区间为 [mid+1,h],此时 l=mid+1</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> solution = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">isBadVersion</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;integer&#125; n Total versions</span></span><br><span class=\"line\"><span class=\"comment\">     * @return &#123;integer&#125; The first bad version</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> l = <span class=\"number\">1</span>, h = n, mid</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">            mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isBadVersion(mid)) h = mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"旋转数组的最小数字\"><a href=\"#旋转数组的最小数字\" class=\"headerlink\" title=\"旋转数组的最小数字\"></a>旋转数组的最小数字</h1><blockquote>\n<p>LeetCode 153</p>\n<p>Input: [3,4,5,1,2],<br>Output: 1</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findMin = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &gt;= nums[h]) l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> h = mid</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums[l]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果第 mid 个数字比 nums[h]小，则最小数字在  [l,mid] 之中， h=mid，否则最小数字在 [mid+1,h]之中。</p>\n<h1 id=\"查找区间\"><a href=\"#查找区间\" class=\"headerlink\" title=\"查找区间\"></a>查找区间</h1><blockquote>\n<p>LeetCode 34</p>\n<p>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]<br>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchRange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> first = binarySearch(nums, target)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> last = binarySearch(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums[first] !== target) <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [first, <span class=\"built_in\">Math</span>.max(last, first)]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> binarySearch = <span class=\"function\">(<span class=\"params\">nums, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &gt;= target) h = mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要查找的值比当前值小或者相等，则要查找的值的最左边在 [l,mid] 此时 h = mid，否则，要查找的值在 [mid+1,h]。</p>\n","categories":["algorithm"],"tags":["LeetCode"]},{"title":"贪心思想","url":"https://xivier.github.io/2019/06/30/贪心思想/","content":"<p>贪心思想的原理：保证每次操作都是局部最优，并且最后的结果是全局最优的。</p>\n<h1 id=\"分配饼干\"><a href=\"#分配饼干\" class=\"headerlink\" title=\"分配饼干\"></a>分配饼干</h1><blockquote>\n<p>LeetCode 455</p>\n<p>Input: [1,2], [1,2,3]<br>Output: 2</p>\n<p>题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于孩子的满足度才能满足孩子。每个孩子只能分配一块饼干。</p>\n</blockquote>\n<p>给每个孩子的饼干应该尽可能小，但是又能满足他。这样满足度大的饼干就能满足满足度比较大的孩子。就可以保证满足最多的孩子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findContentChildren = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">g, s</span>) </span>&#123;</span><br><span class=\"line\">  g.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  s.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> gi = <span class=\"number\">0</span>, si = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (gi &lt; g.length &amp;&amp; si &lt; s.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[si] &gt;= g[gi]) &#123;</span><br><span class=\"line\">      gi++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    si++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gi</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不重叠的区间个数\"><a href=\"#不重叠的区间个数\" class=\"headerlink\" title=\"不重叠的区间个数\"></a>不重叠的区间个数</h1><blockquote>\n<p>LeetCode 435</p>\n<p>Input: [ [1,2], [1,2], [1,2] ]<br>Output: 2</p>\n<p>题目描述：计算一组区间要做到不重叠，需要移除的区间个数。要做到移除的区间个数最小，即要计算最多能组成的不重叠区间数。然后用总区间减去不重叠的区间数。</p>\n</blockquote>\n<p>每次选择，区间结尾如果小于等于区间开头，则不重叠。区间的结尾越小，留给后面的区间的空间越大，可以选择的区间个数也越大。</p>\n<p>所以对区间的结尾进行排序，每次选择结尾最小，并且和前一个不重叠的区间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> eraseOverlapIntervals = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">intervals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (intervals.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  intervals.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>])</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>, end = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end &gt; intervals[i][<span class=\"number\">0</span>]) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    end = intervals[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">    res++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> intervals.length - res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一定要考虑边界值。当传入空数组时，返回0。</p>\n<h1 id=\"投飞镖刺破气球\"><a href=\"#投飞镖刺破气球\" class=\"headerlink\" title=\"投飞镖刺破气球\"></a>投飞镖刺破气球</h1><blockquote>\n<p>LeetCode 452</p>\n<p>Input:<br>[[10,16], [2,8], [1,6], [7,12]]<br>Output:<br>2</p>\n<p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直坐标轴投向，使得路径上的气球都被刺破。求解最小的投飞镖次数使得所有气球都被刺破。</p>\n</blockquote>\n<p>计算不重叠的区间个数，区别是边界也是重叠区间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findMinArrowShots = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">points</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (points.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  points.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>])</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>, end = points[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; points.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end &gt;= points[i][<span class=\"number\">0</span>]) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    res++</span><br><span class=\"line\">    end = points[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"根据身高和序号重组队列\"><a href=\"#根据身高和序号重组队列\" class=\"headerlink\" title=\"根据身高和序号重组队列\"></a>根据身高和序号重组队列</h1><blockquote>\n<p>LeetCode 406</p>\n<p>Input:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]<br>Output:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>\n<p>题目描述：每个学生用两个分量表示（h,k）,h表示身高，k表示前面有&gt;=k个学生的身高和他一样高。</p>\n<p>因为包保证前面有k个学生的身高大于等于他本身。所以先h降序排列，k升序排列。每个学生都插入到底k个位置，保证前面有k个学生身高大于等于他。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reconstructQueue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">people</span>) </span>&#123;</span><br><span class=\"line\">  people.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] === b[<span class=\"number\">0</span>] ? a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>] : b[<span class=\"number\">0</span>] - a[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(people)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> people) &#123;</span><br><span class=\"line\">    res.splice(i[<span class=\"number\">1</span>], <span class=\"number\">0</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"买卖股票最大的收益-I\"><a href=\"#买卖股票最大的收益-I\" class=\"headerlink\" title=\"买卖股票最大的收益 I\"></a>买卖股票最大的收益 I</h1><blockquote>\n<p>LeetCode 121</p>\n<p>题目描述：只进行一次股票交易，买入卖出求最大利益。</p>\n</blockquote>\n<p>记录前面的最小价格，然后将整个最小价格作为买入价格。将当前价格作为售出价格，查看当前收益是不是最大收益。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxProfit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">prices</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minPrice = prices[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rase = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &lt; minPrice) minPrice = prices[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &gt; minPrice) rase = prices[i] - minPrice</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rase &gt; res) res = rase</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"买卖股票的最大收益-II\"><a href=\"#买卖股票的最大收益-II\" class=\"headerlink\" title=\"买卖股票的最大收益 II\"></a>买卖股票的最大收益 II</h1><blockquote>\n<p>LeetCode 122</p>\n<p>题目描述：可以进行多次交易，但是交易不能交叉。即买入股票，卖了之后才买再买。求最大利益</p>\n</blockquote>\n<p>只要当前的金额大于前一项的金额，即可看做获得收益。即每次到当前金额时保证之前的利润都是最大的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxProfit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">prices</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &gt; prices[i - <span class=\"number\">1</span>]) res += prices[i] - prices[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"种植花朵\"><a href=\"#种植花朵\" class=\"headerlink\" title=\"种植花朵\"></a>种植花朵</h1><blockquote>\n<p>LeetCode 605</p>\n<p>Input: flowerbed = [1,0,0,0,1], n = 1<br>Output: True</p>\n<p>题目描述：1 表示种植了花朵，0 表示没有种植花朵。花朵之间至少间隔一个单位的间隙。求解是否能种下 n 朵花</p>\n</blockquote>\n<p>需要考虑边界，在第一个和最后个位置时考虑左边和右边可以看做 0 ，没有种植花朵。其他位置时，看左右是否种植花朵，如果都为0，则当前位置可以设置1，然后计数器+1，最后看计数器的大小是否大于等于n。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canPlaceFlowers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">flowerbed, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; flowerbed.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flowerbed[i] === <span class=\"number\">1</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> pre = i === <span class=\"number\">0</span> ? <span class=\"number\">0</span> : flowerbed[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> next = i === flowerbed.length - <span class=\"number\">1</span> ? <span class=\"number\">0</span> : flowerbed[i + <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre === <span class=\"number\">0</span> &amp;&amp; next === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      flowerbed[i] = <span class=\"number\">1</span></span><br><span class=\"line\">      res++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(flowerbed)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res &gt;= n</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"判断是否为子序列\"><a href=\"#判断是否为子序列\" class=\"headerlink\" title=\"判断是否为子序列\"></a>判断是否为子序列</h1><blockquote>\n<p>LeetCode 392</p>\n<p>s = “abc”, t = “ahbgdc”<br>Return true.</p>\n</blockquote>\n<p>遍历需要判断子序列的序列，对于子序列的每一个字符，在对照序列中依次从左至右遍历，如果找到了，子序列指向下一位，然后对照序列接着遍历，重复此步骤。如果对照序列遍历完成后，子序列也遍历完成了，说明是子序列，否则不是。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isSubsequence = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s, t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> s0 = <span class=\"number\">0</span>, t0 = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (t0 &lt; t.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[s0] === t[t0]) &#123;</span><br><span class=\"line\">      s0++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    t0++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s0 === s.length</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修改一个数变成非递减数组\"><a href=\"#修改一个数变成非递减数组\" class=\"headerlink\" title=\"修改一个数变成非递减数组\"></a>修改一个数变成非递减数组</h1><blockquote>\n<p>LeetCode 665</p>\n<p>Input: [4,2,3]<br>Output: True</p>\n<p>题目描述：判断一个数组能否只修改一个数，使之变成非递减数组。</p>\n</blockquote>\n<p>当 nums[i] &lt; nums[i-1] 时，需要思考，修改哪一个数。理论上两个都可以修改。nums[i] = nums[i-1] or nums[i-1]  = nums[i] 都可以。如果修改当前数的话，会使之变大，影响后序的判断。所以一般情况修改前一个数。</p>\n<p><strong>特殊情况：</strong>当前的数比 nums[i-2] 还要小，由于之前的数已经排序好了，此时再改变 nums[i-1] 会使得 nums[i-1] 变小，所以此时 nums[i] = nums[i-1]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> checkPossibility = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; nums.length &amp;&amp; res &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] &gt;= nums[i - <span class=\"number\">1</span>]) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    res++</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">2</span> &amp;&amp; nums[i] &lt; nums[i - <span class=\"number\">2</span>]) nums[i] = nums[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">else</span> nums[i - <span class=\"number\">1</span>] = nums[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res &lt;= <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"子数组最大的和\"><a href=\"#子数组最大的和\" class=\"headerlink\" title=\"子数组最大的和\"></a>子数组最大的和</h1><blockquote>\n<p>LeetCode 53</p>\n<p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>\n</blockquote>\n<p>当遍历到当前数时，保证之前的最大和是最大的。</p>\n<p>要保证连续数组的最大和，所以负数连续肯定会使最后的值变小。</p>\n<p>所以当之前的连续和为负数时，当遇到当前值时，丢弃掉之前的和，从当前值开始计算。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxSubArray = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> preSum = nums[<span class=\"number\">0</span>], maxSum = preSum</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    preSum = preSum &gt; <span class=\"number\">0</span> ? preSum + nums[i] : nums[i]</span><br><span class=\"line\">    maxSum = <span class=\"built_in\">Math</span>.max(maxSum, preSum)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxSum</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"分隔字符串使同种字符出现在一起\"><a href=\"#分隔字符串使同种字符出现在一起\" class=\"headerlink\" title=\"分隔字符串使同种字符出现在一起\"></a>分隔字符串使同种字符出现在一起</h1><blockquote>\n<p>LeetCode 763</p>\n<p>Input: S = “ababcbacadefegdehijhklij”<br>Output: [9,7,8]</p>\n<p>题目要求：要求分割的数组大小最大。</p>\n</blockquote>\n<p>从左至右遍历字符串，对于每个字符，找到它最后出现的位置。然后对这个区间进行遍历，看它最后出现的位置是否大于之前的字符最后出现的位置，如果大于则扩展这个区间。遍历完成后，同一个字母都值出现在这个区间内。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> partitionLabels = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> firstIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (firstIndex &lt; S.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastIndex = firstIndex</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = firstIndex; i &lt; S.length &amp;&amp; i &lt;= lastIndex; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = S.lastIndexOf(S[i])</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index &gt; lastIndex) &#123;</span><br><span class=\"line\">        lastIndex = index</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.push(lastIndex - firstIndex + <span class=\"number\">1</span>)</span><br><span class=\"line\">    firstIndex = lastIndex + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","categories":["algorithm"],"tags":["LeetCode"]},{"title":"排序","url":"https://xivier.github.io/2019/06/29/排序/","content":"<h1 id=\"快速选择\"><a href=\"#快速选择\" class=\"headerlink\" title=\"快速选择\"></a>快速选择</h1><p>利用了快速排序的思想，求解第 K 个元素的问题。利用的是快速排序的划分思想 partition() 进行实现的。需要先打乱数组，不然最坏的情况复杂度为 O(N^2)。</p>\n<p>快速排序的每次 partition() 过程中都排好一个位置。如果排好的是正数第K个位置，那么它就是第K小的元素。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>预备知识：</p>\n<ul>\n<li>堆是一个完全二叉树</li>\n<li>完全二叉树：除开最后一层，其他层的节点数都达到最大，最后一层的所有节点都集中在左边。</li>\n<li>大根堆：根节点为最大值，每个结点的值大于等于孩子结点的值。</li>\n<li>小根堆：根节点的值为最小值，每个根节点的值都小于等于孩子结点的值。</li>\n<li>堆的存储：用数组来存储。</li>\n<li>对于节点i，子节点为2i+1 与 2i+2</li>\n<li>堆排序算法（以大根堆（heapify）为例）：<ol>\n<li>对每一个非叶子节点，从下至上，从右至左，做 shiftDown 下沉操作。操作后根节点为最大值，将其与最后一个结点交换。</li>\n<li>除开最后一个节点，其余节点继续转化成大根堆，此时根节点为次最大，将其与最后一个结点交换。</li>\n<li>重复2，直到堆中元素个数为1，排序完成。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> swap = <span class=\"function\">(<span class=\"params\">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> shiftDowm = <span class=\"function\">(<span class=\"params\">arr, i, length</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>; j &lt; length; j = j * <span class=\"number\">2</span> + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = arr[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; length &amp;&amp; arr[j + <span class=\"number\">1</span>] &gt; arr[j]) &#123;</span><br><span class=\"line\">      j++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; temp) &#123;</span><br><span class=\"line\">      swap(arr, i, j)</span><br><span class=\"line\">      i = j</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> heapSort = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span> - <span class=\"number\">1</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    shiftDowm(arr, i, arr.length)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    swap(arr, <span class=\"number\">0</span>, i)</span><br><span class=\"line\">    shiftDowm(arr, <span class=\"number\">0</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用于求解第 K 个最小元素问题。可以维护一个大小为K的大根堆。大根堆的堆顶元素即为该堆的最大值。每次遍历新元素时，如果比堆顶元素小，则把堆顶元素去除，将新元素加到堆中，调整堆。遍历完之后，堆里面的K个元素是从小到大排列的，堆顶即为第K个最小元素。</p>\n<p>也可以用于求解第K个最大元素的问题。维护一个K大小的小根堆。</p>\n<h2 id=\"JS-实现堆排序\"><a href=\"#JS-实现堆排序\" class=\"headerlink\" title=\"JS 实现堆排序\"></a>JS 实现堆排序</h2><h1 id=\"Kth-Element\"><a href=\"#Kth-Element\" class=\"headerlink\" title=\"Kth Element\"></a>Kth Element</h1><blockquote>\n<p>LeetCode 215</p>\n<p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5</p>\n<p>题目描述：找出倒数第K大的元素</p>\n</blockquote>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><blockquote>\n<p>时间复杂度 O(NlogN),空间复杂度 O(1)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findKthLargest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">    nums.sort();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[nums.length-k]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>先用自带的排序方法进行排序，然后再取倒数第k个元素</p>\n<h2 id=\"堆-1\"><a href=\"#堆-1\" class=\"headerlink\" title=\"堆\"></a>堆</h2><blockquote>\n<p>时间复杂度 O(NlogK)，空间复杂度 O(K)。</p>\n</blockquote>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><blockquote>\n<p>时间复杂度 O(N)，空间复杂度 O(1)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findKthLargest = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">  k = nums.length - k</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, r = nums.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = partition(nums, l, r)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res === k) <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res &gt; k) r = res - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = res + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums[k]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> partition = <span class=\"function\">(<span class=\"params\">nums, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = i, r = j + <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; j &amp;&amp; nums[++l] &lt; nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (r &gt; i &amp;&amp; nums[--r] &gt; nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    [nums[l], nums[r]] = [nums[r], nums[l]]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  [nums[i], nums[r]] = [nums[r], nums[i]]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过每次划分，找出倒数第k个元素就行。</p>\n<h1 id=\"出现频率最多的-k-个元素\"><a href=\"#出现频率最多的-k-个元素\" class=\"headerlink\" title=\"出现频率最多的 k 个元素\"></a>出现频率最多的 k 个元素</h1><blockquote>\n<p>LeetCode 347</p>\n<p>Given [1,1,1,2,2,3] and k = 2, return [1,2].</p>\n</blockquote>\n<p>设置若干个桶，桶的下标表示出现的频率，即第 i 个桶里存储的数出现的频率为 i。都存到桶里之后，根据桶的频率进行排序，从后往前遍历，最先得到的k个元素即为出现频率最多的k个元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> topKFrequent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> nums) &#123;</span><br><span class=\"line\">    map.set(i, map.get(i) + <span class=\"number\">1</span> || <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sortedArray = [...map.entries()].sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b[<span class=\"number\">1</span>] - a[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">    res.push(sortedArray[i][<span class=\"number\">0</span>])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"按照字符串出现次数对字符串进行排序\"><a href=\"#按照字符串出现次数对字符串进行排序\" class=\"headerlink\" title=\"按照字符串出现次数对字符串进行排序\"></a>按照字符串出现次数对字符串进行排序</h1><blockquote>\n<p>LeetCode 451</p>\n<p>Input:<br>“tree”<br>Output:<br>“eert”</p>\n</blockquote>\n<p>同上题，先用桶存所有字符，按照字符的频率进行排序，从最多频率往最少频率进行打印即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> frequencySort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">    map.set(i, map.get(i) + <span class=\"number\">1</span> || <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [];</span><br><span class=\"line\">  [...map.entries()].sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b[<span class=\"number\">1</span>] - a[<span class=\"number\">1</span>]).forEach(<span class=\"function\"><span class=\"params\">cur</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; cur[<span class=\"number\">1</span>]; i++) &#123;</span><br><span class=\"line\">      res.push(cur[<span class=\"number\">0</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.join(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"荷兰国旗问题\"><a href=\"#荷兰国旗问题\" class=\"headerlink\" title=\"荷兰国旗问题\"></a>荷兰国旗问题</h1><blockquote>\n<p>LeetCode 75 </p>\n<p>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]</p>\n<p>题目描述：按照 0 1 2 顺序进行排序，不能使用原始的排序</p>\n</blockquote>\n<p>运用划分的思想，等于零的放左边，等于二的划分到右边，最后中间就是等于1的了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortColors = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> zero = <span class=\"number\">-1</span>, one = <span class=\"number\">0</span>, two = nums.length</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (one &lt; two) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[one] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      zero++</span><br><span class=\"line\">      [nums[zero], nums[one]] = [nums[one], nums[zero]]</span><br><span class=\"line\">      one++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[one] === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      two--</span><br><span class=\"line\">      [nums[two], nums[one]] = [nums[one], nums[two]]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      one++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","categories":["algorithm"],"tags":["LeetCode"]},{"title":"双指针","url":"https://xivier.github.io/2019/06/28/双指针/","content":"<h1 id=\"1-有序数组的-Two-Sum\"><a href=\"#1-有序数组的-Two-Sum\" class=\"headerlink\" title=\"1. 有序数组的 Two Sum\"></a>1. 有序数组的 Two Sum</h1><p>LeetCode 167</p>\n<p>Input: numbers 有序数组,target 需要求和的值<br>Output: index1,index2  两个值的下标，注意从1开始</p>\n<p>题目描述：在有序数组中寻找两个数，使之和为 target</p>\n<p>使用双指针，一个指针指向较小的元素，一个指针指向较大的元素。小指针从头开始往后遍历，大指针从尾开始往前遍历。</p>\n<ul>\n<li>如果两个指针指向的元素和为 target 则得到了要求的结果</li>\n<li>如果 sum &gt; target 说明结果大了，大指针需要前移</li>\n<li>如果 sum &lt; target 说明结果小了，小指针需要后移</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; numbers</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; target</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> twoSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">numbers, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"number\">0</span>, p2 = numbers.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 &lt; p2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numbers[p1] + numbers[p2] === target) <span class=\"keyword\">return</span> [p1 + <span class=\"number\">1</span>, p2 + <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numbers[p1] + numbers[p2] &lt; target) p1++</span><br><span class=\"line\">    <span class=\"keyword\">else</span> p2--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-两数平方和\"><a href=\"#2-两数平方和\" class=\"headerlink\" title=\"2. 两数平方和\"></a>2. 两数平方和</h1><p>LeetCode 633</p>\n<p>Input: 5<br>Output: True</p>\n<p>题目描述：判断一个数是否是两个数的平方和</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> judgeSquareSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"number\">0</span>, p2 = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.sqrt(c))</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 &lt;= p2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 * p1 + p2 * p2 === c) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p1 * p1 + p2 * p2 &gt; c) p2--</span><br><span class=\"line\">    <span class=\"keyword\">else</span> p1++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-反转字符串中的元音字母\"><a href=\"#3-反转字符串中的元音字母\" class=\"headerlink\" title=\"3. 反转字符串中的元音字母\"></a>3. 反转字符串中的元音字母</h1><p>LeetCode 345</p>\n<p>Input: “LeetCode”<br>Output: “LeoCede”</p>\n<p>解题思路：使用双指针指向待反转的两个元音字母，一个指针从头遍历，一个指针从尾遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reverseVowels = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> VOWELS = &#123; <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'e'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'u'</span>: <span class=\"number\">1</span>, <span class=\"string\">'A'</span>: <span class=\"number\">1</span>, <span class=\"string\">'E'</span>: <span class=\"number\">1</span>, <span class=\"string\">'I'</span>: <span class=\"number\">1</span>, <span class=\"string\">'O'</span>: <span class=\"number\">1</span>, <span class=\"string\">'U'</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = s.split(<span class=\"string\">''</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = arr.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (VOWELS[arr[i]] &amp;&amp; VOWELS[arr[j]]) &#123;</span><br><span class=\"line\">      [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (VOWELS[arr[i]]) j--</span><br><span class=\"line\">    <span class=\"keyword\">else</span> i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.join(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-回文字符串\"><a href=\"#4-回文字符串\" class=\"headerlink\" title=\"4. 回文字符串\"></a>4. 回文字符串</h1><p>LeetCode 680</p>\n<p>Input: “abca”<br>Output: true</p>\n<p>题目描述：可以删除一个字符，判断是否可以构成回文串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> validPalindrome = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = s.length<span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] !== s[j]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> judge(s, i + <span class=\"number\">1</span>, j) || judge(s, i, j - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> judge = <span class=\"function\">(<span class=\"params\">s, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] !== s[j]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">    j--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-归并两个有序数组\"><a href=\"#5-归并两个有序数组\" class=\"headerlink\" title=\"5. 归并两个有序数组\"></a>5. 归并两个有序数组</h1><p>LeetCode 88</p>\n<p>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [4,5,6], n = 3</p>\n<p>Output:<br>[1,2,3,4,5,6]</p>\n<p>题目描述：把结果归并在第一个数组上</p>\n<p>需要从尾部开始遍历，不然结果会覆盖未进行归并的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = m - <span class=\"number\">1</span>, p2 = n - <span class=\"number\">1</span>, mergeIndex = m + n - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 &gt;= <span class=\"number\">0</span> || p2 &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums2[p2--]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p2 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums1[p1--]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums2[p2] &gt;= nums1[p1]) &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums2[p2--]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums1[p1--]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-判断链表是否存在环\"><a href=\"#6-判断链表是否存在环\" class=\"headerlink\" title=\"6. 判断链表是否存在环\"></a>6. 判断链表是否存在环</h1><p>LeetCode 141</p>\n<p>使用双指针，一个指针一次移动一个节点，一个一次移动两个节点，如果存在环，则两个指针一定会相遇。<br>PS: 起始时不能使两个指针指向同一个节点，一前一后不会出问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hasCycle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = head, p2 = head.next</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 !== <span class=\"literal\">null</span> &amp;&amp; p2 !== <span class=\"literal\">null</span> &amp;&amp; p2.next !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 === p2) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    p1 = p1.next</span><br><span class=\"line\">    p2 = p2.next.next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-最长子序列\"><a href=\"#7-最长子序列\" class=\"headerlink\" title=\"7. 最长子序列\"></a>7. 最长子序列</h1><p>LeetCode 524</p>\n<p>Input:<br>s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]</p>\n<p>Output:<br>“apple”</p>\n<p>题目描述：删除 s 中的一些字符，使之能构成 d 列表中的一个字符串，找出能构成的最长字符串，如果字符串长度相同，则取字典序最小的。</p>\n<p>通过删除 s 中的一些字符获得字符串 t，可以认为 t 是 s 的子串序列，我们可以用双指针判断一个字符串是否是另一个字符串的子序列</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findLongestWord = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s, d</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> longestCode = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> cur <span class=\"keyword\">of</span> d) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> l1 = longestCode.length, l2 = cur.length</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1 &gt; l2 || (l1 === l2 &amp;&amp; cur &gt; longestCode))</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSubStr(s, cur)) &#123;</span><br><span class=\"line\">      longestCode = cur</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> longestCode</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isSubStr = <span class=\"function\">(<span class=\"params\">s, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; s.length &amp;&amp; j &lt; target.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] === target[j]) &#123;</span><br><span class=\"line\">      j++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> j === target.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["algorithm"],"tags":["LeetCode"]},{"title":"about","url":"https://xivier.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://xivier.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://xivier.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"https://xivier.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://xivier.github.io/tag/index.html","content":"","categories":[],"tags":[]}]