[{"title":"","url":"https://xivier.github.io/2019/07/21/diff算法的优化/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/v-for事件代理/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/编程算法题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/下列代码的打印结果/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现深拷贝/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/前端加密/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/数组编程题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/输出下列代码的执行结果/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/移动端Retina屏1px像素问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/设计LazyMan类/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/比较opacity visibility display的优劣/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/模拟实现Promise.finally/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Vue中的Object.defineProperty/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/旋转数组/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/call和allly的区别/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/点调用和括号调用的性能比较/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/for和forEach/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/计算两个数组的交集/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/input防抖/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/react-router问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/HTTPS中间人攻击/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/var let const 实现原理/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/webpack热更新/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/父子组件生命周期钩子函数执行顺序/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Promise.all/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/数组里取第一个元素和第十万个元素/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/BFC IFC GFC FFC/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/两个有序数组中的中位数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/两数之和/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/找出链条中的父ID/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/打印对称数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/为什么把reducer设计成纯函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/输出运行结果/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/修改图片的宽度为300px/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现模糊搜索/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/冒泡排序的实现过程/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/判断是一个正确的网址/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Proxy实现数据绑定/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/双向绑定和Vuex是否冲突/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/埋点请求问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/箭头函数和普通函数的区别/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/移动零/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何实现无缝轮播/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何将销售额存到一个对象里/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何将ES6代码转ES5代码/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何让一个div水平垂直居中/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/字符串大小取反/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/字符串的匹配/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现Promise.race/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现add.minus功能/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现add函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现convert方法/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现token加密/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/下列代码执行结果是什么/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/HTTPS握手过程/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/代码输出什么/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/HTTPS握手中证书校验问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/sort()排序问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现一个sleep函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Vue中子组件为何不能修改父组件传递的Prop/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/模块化发展历程/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/为什么不会劫持token/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/为什么Vuex的mutation和Redux的reducer中不能做异步操作/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/改造代码打印10和20/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/下面代码打印什么内容/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/下面代码什么时候会打印1/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Vue的双向绑定/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/BFC/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/全局作用域中的const和let/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Virtual DOM问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/迭代方式实现flatten函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/浏览器缓存读取规则/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/输出0-9的所有写法/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/合并数组问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/浏览器和Node事件循环/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Redux和Vuex的设计思想/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/观察者模式和订阅发布者模式/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/重绘和回流/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/3种判断数组的方法/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/npm模块安装机制/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/TCP三次握手四次挥手/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/JS异步解决方案/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何实现new/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/一题算法手写题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/一题异步笔试题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/http2多路富用/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/重启后TCP状态问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/React中的setState问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Promise构造函数的执行/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/一题关于React中的setState笔试题/","content":"<p>F</p>\n","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/深度优先思想和广度优先思想实现拷贝函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Async和Await如何通过同步实现异步/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/ES5和ES6中的继承/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/深度优先遍历和广度优先遍历/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/防抖和节流/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Set、Map、WeakSet、WeakMap/","content":"","categories":[],"tags":[]},{"title":"React和Vue中的key值问题","url":"https://xivier.github.io/2019/07/01/React和Vue中的key值问题/","content":"","categories":["algorithm"],"tags":["LeetCode"]},{"title":"二分查找","url":"https://xivier.github.io/2019/06/30/二分查找/","content":"<h1 id=\"原始二分查找\"><a href=\"#原始二分查找\" class=\"headerlink\" title=\"原始二分查找\"></a>原始二分查找</h1><blockquote>\n<p>Input : [1,2,3,4,5]<br>key : 3<br>return the index : 2</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binarySearch = <span class=\"function\">(<span class=\"params\">nums, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span>, mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt;= h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] === key) <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; key) h = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度：二分查找，每次将查找区间减半，这种折半特性的时间复杂度为 O(logN)</p>\n<p>返回值：</p>\n<ul>\n<li>-1：表示没有查找到 key。</li>\n<li>l：表示插入到 nums 中的正确位置。</li>\n</ul>\n<p>变种：</p>\n<p>二分查找有很多变种，变种要注意边界值的判断。例如在一个有重复元素中的数组中查找最左边的 key 值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binarySearch = <span class=\"function\">(<span class=\"params\">nums, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span>, mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key &lt;= nums[mid]) h = mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和上述的实现有什么不同呢？</p>\n<ul>\n<li>赋值表达式变成了 h = mid</li>\n<li>循环语句变成了 l &lt; h</li>\n<li>最后返回的是 l</li>\n</ul>\n<p>因为要找最左的值，所以设置 key &lt;= nums[mid] 时，最左的区间位于 [l,mid] 中，此时将 h = mid，因为 mid 所在的位置也可以是解。</p>\n<p>如果要找最右的值，应当设置 key &gt;= nums[mid] 时，最右的区间位于 [mid,h] 中，此时将 l = mid，因为 mid 所在的位置也可以是解。</p>\n<p>在 h = m 情况下，如果循环条件为 l &lt;= h，那么有可能会出现无限循环无法退出的情况。</p>\n<h1 id=\"求开方\"><a href=\"#求开方\" class=\"headerlink\" title=\"求开方\"></a>求开方</h1><blockquote>\n<p>LeetCode 69</p>\n<p>Input: 4<br>Output: 2<br>Input: 8<br>Output: 2</p>\n<p>如果开方开不尽，开方结果向下取整。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mySqrt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">1</span>, h = x</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt;= h) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sqrt = <span class=\"built_in\">Math</span>.floor(x / mid)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sqrt === mid) <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sqrt &lt; mid) h = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>通过二分查找来查找开方数 sqrt，因为 sqrt * sqrt = x。所以可以对 1 -  x 的区间进行二分查找。</p>\n<p>本题关键是最后的返回值，退出循环时， l &gt; h，当开方开不尽的时候，结果就是 h ，为什么是 h 不是 l 呢？循环退出时， h 总是比 l 小1，由于本题要向下取整，所以取 h。</p>\n<h1 id=\"大于给定元素的最小元素\"><a href=\"#大于给定元素的最小元素\" class=\"headerlink\" title=\"大于给定元素的最小元素\"></a>大于给定元素的最小元素</h1><blockquote>\n<p>LeetCode 744</p>\n<p>Input:<br>letters = [“c”, “f”, “j”]<br>target = “d”<br>Output: “f”<br>Input:<br>letters = [“c”, “f”, “j”]<br>target = “k”<br>Output: “c”</p>\n<p>题目描述：给定一个有序的字符数组 letters，再给定一个字符 target，要求在 letters 中查找大于 target 的最小字符。如果找不到就返回第一个元素。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nextGreatestLetter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">letters, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = letters.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt;= h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (letters[mid] &lt;= target) &#123;</span><br><span class=\"line\">      l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      h = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l &lt; letters.length ? letters[l] : letters[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于字符数组是有序的，根据有序数组查找指定字符，想到用二分查找。</p>\n<h1 id=\"有序数组的-Single-Element\"><a href=\"#有序数组的-Single-Element\" class=\"headerlink\" title=\"有序数组的 Single Element\"></a>有序数组的 Single Element</h1><blockquote>\n<p>LeetCode 540</p>\n<p>Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]<br>Output: 2</p>\n<p>一个有序数组只有一个数不出现两次，找出这个数</p>\n</blockquote>\n<p>时间复杂度要求 O(logN)，因此很容易想到用二分查找。</p>\n<p>假设index 为 Single Element 出现在数组中的位置。在 index 之后，数组原来的下标状态将会改变。如果 m 为偶数， m+1 &lt; index，那么，nums[m] = nums[m+1]；m+1 &gt;=index，那么 nums[m] != nums[m+1]</p>\n<p>所以可知， 如果 nums[m] === nums[m+1] 则 target 所在的区间为 [m+2,h]；如果 nums[m] !=== nums[m+1] 则 target 所在区间为 [l,m]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> singleNonDuplicate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span>, mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mid % <span class=\"number\">2</span> === <span class=\"number\">1</span>) mid -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] === nums[mid + <span class=\"number\">1</span>]) l = mid + <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> h = mid</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums[h]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第一个错误的版本\"><a href=\"#第一个错误的版本\" class=\"headerlink\" title=\"第一个错误的版本\"></a>第一个错误的版本</h1><blockquote>\n<p>LeetCode 278</p>\n<p>题目描述：找到一个错误版本。</p>\n<p>如果第 mid 个版本出错，那么第一个错误版本所在区间为 [l,mid]，此时 h=mid；否认第一个错误区间为 [mid+1,h],此时 l=mid+1</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> solution = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">isBadVersion</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;integer&#125; n Total versions</span></span><br><span class=\"line\"><span class=\"comment\">     * @return &#123;integer&#125; The first bad version</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> l = <span class=\"number\">1</span>, h = n, mid</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">            mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isBadVersion(mid)) h = mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"旋转数组的最小数字\"><a href=\"#旋转数组的最小数字\" class=\"headerlink\" title=\"旋转数组的最小数字\"></a>旋转数组的最小数字</h1><blockquote>\n<p>LeetCode 153</p>\n<p>Input: [3,4,5,1,2],<br>Output: 1</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findMin = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &gt;= nums[h]) l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> h = mid</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums[l]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果第 mid 个数字比 nums[h]小，则最小数字在  [l,mid] 之中， h=mid，否则最小数字在 [mid+1,h]之中。</p>\n<h1 id=\"查找区间\"><a href=\"#查找区间\" class=\"headerlink\" title=\"查找区间\"></a>查找区间</h1><blockquote>\n<p>LeetCode 34</p>\n<p>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]<br>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchRange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> first = binarySearch(nums, target)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> last = binarySearch(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums[first] !== target) <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [first, <span class=\"built_in\">Math</span>.max(last, first)]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> binarySearch = <span class=\"function\">(<span class=\"params\">nums, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &gt;= target) h = mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要查找的值比当前值小或者相等，则要查找的值的最左边在 [l,mid] 此时 h = mid，否则，要查找的值在 [mid+1,h]。</p>\n","categories":["algorithm"],"tags":["LeetCode"]},{"title":"贪心思想","url":"https://xivier.github.io/2019/06/30/贪心思想/","content":"<p>贪心思想的原理：保证每次操作都是局部最优，并且最后的结果是全局最优的。</p>\n<h1 id=\"分配饼干\"><a href=\"#分配饼干\" class=\"headerlink\" title=\"分配饼干\"></a>分配饼干</h1><blockquote>\n<p>LeetCode 455</p>\n<p>Input: [1,2], [1,2,3]<br>Output: 2</p>\n<p>题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于孩子的满足度才能满足孩子。每个孩子只能分配一块饼干。</p>\n</blockquote>\n<p>给每个孩子的饼干应该尽可能小，但是又能满足他。这样满足度大的饼干就能满足满足度比较大的孩子。就可以保证满足最多的孩子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findContentChildren = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">g, s</span>) </span>&#123;</span><br><span class=\"line\">  g.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  s.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> gi = <span class=\"number\">0</span>, si = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (gi &lt; g.length &amp;&amp; si &lt; s.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[si] &gt;= g[gi]) &#123;</span><br><span class=\"line\">      gi++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    si++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gi</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不重叠的区间个数\"><a href=\"#不重叠的区间个数\" class=\"headerlink\" title=\"不重叠的区间个数\"></a>不重叠的区间个数</h1><blockquote>\n<p>LeetCode 435</p>\n<p>Input: [ [1,2], [1,2], [1,2] ]<br>Output: 2</p>\n<p>题目描述：计算一组区间要做到不重叠，需要移除的区间个数。要做到移除的区间个数最小，即要计算最多能组成的不重叠区间数。然后用总区间减去不重叠的区间数。</p>\n</blockquote>\n<p>每次选择，区间结尾如果小于等于区间开头，则不重叠。区间的结尾越小，留给后面的区间的空间越大，可以选择的区间个数也越大。</p>\n<p>所以对区间的结尾进行排序，每次选择结尾最小，并且和前一个不重叠的区间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> eraseOverlapIntervals = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">intervals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (intervals.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  intervals.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>])</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>, end = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end &gt; intervals[i][<span class=\"number\">0</span>]) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    end = intervals[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">    res++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> intervals.length - res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一定要考虑边界值。当传入空数组时，返回0。</p>\n<h1 id=\"投飞镖刺破气球\"><a href=\"#投飞镖刺破气球\" class=\"headerlink\" title=\"投飞镖刺破气球\"></a>投飞镖刺破气球</h1><blockquote>\n<p>LeetCode 452</p>\n<p>Input:<br>[[10,16], [2,8], [1,6], [7,12]]<br>Output:<br>2</p>\n<p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直坐标轴投向，使得路径上的气球都被刺破。求解最小的投飞镖次数使得所有气球都被刺破。</p>\n</blockquote>\n<p>计算不重叠的区间个数，区别是边界也是重叠区间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findMinArrowShots = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">points</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (points.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  points.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>])</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>, end = points[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; points.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end &gt;= points[i][<span class=\"number\">0</span>]) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    res++</span><br><span class=\"line\">    end = points[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"根据身高和序号重组队列\"><a href=\"#根据身高和序号重组队列\" class=\"headerlink\" title=\"根据身高和序号重组队列\"></a>根据身高和序号重组队列</h1><blockquote>\n<p>LeetCode 406</p>\n<p>Input:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]<br>Output:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>\n<p>题目描述：每个学生用两个分量表示（h,k）,h表示身高，k表示前面有&gt;=k个学生的身高和他一样高。</p>\n<p>因为包保证前面有k个学生的身高大于等于他本身。所以先h降序排列，k升序排列。每个学生都插入到底k个位置，保证前面有k个学生身高大于等于他。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reconstructQueue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">people</span>) </span>&#123;</span><br><span class=\"line\">  people.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] === b[<span class=\"number\">0</span>] ? a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>] : b[<span class=\"number\">0</span>] - a[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(people)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> people) &#123;</span><br><span class=\"line\">    res.splice(i[<span class=\"number\">1</span>], <span class=\"number\">0</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"买卖股票最大的收益-I\"><a href=\"#买卖股票最大的收益-I\" class=\"headerlink\" title=\"买卖股票最大的收益 I\"></a>买卖股票最大的收益 I</h1><blockquote>\n<p>LeetCode 121</p>\n<p>题目描述：只进行一次股票交易，买入卖出求最大利益。</p>\n</blockquote>\n<p>记录前面的最小价格，然后将整个最小价格作为买入价格。将当前价格作为售出价格，查看当前收益是不是最大收益。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxProfit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">prices</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minPrice = prices[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rase = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &lt; minPrice) minPrice = prices[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &gt; minPrice) rase = prices[i] - minPrice</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rase &gt; res) res = rase</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"买卖股票的最大收益-II\"><a href=\"#买卖股票的最大收益-II\" class=\"headerlink\" title=\"买卖股票的最大收益 II\"></a>买卖股票的最大收益 II</h1><blockquote>\n<p>LeetCode 122</p>\n<p>题目描述：可以进行多次交易，但是交易不能交叉。即买入股票，卖了之后才买再买。求最大利益</p>\n</blockquote>\n<p>只要当前的金额大于前一项的金额，即可看做获得收益。即每次到当前金额时保证之前的利润都是最大的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxProfit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">prices</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &gt; prices[i - <span class=\"number\">1</span>]) res += prices[i] - prices[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"种植花朵\"><a href=\"#种植花朵\" class=\"headerlink\" title=\"种植花朵\"></a>种植花朵</h1><blockquote>\n<p>LeetCode 605</p>\n<p>Input: flowerbed = [1,0,0,0,1], n = 1<br>Output: True</p>\n<p>题目描述：1 表示种植了花朵，0 表示没有种植花朵。花朵之间至少间隔一个单位的间隙。求解是否能种下 n 朵花</p>\n</blockquote>\n<p>需要考虑边界，在第一个和最后个位置时考虑左边和右边可以看做 0 ，没有种植花朵。其他位置时，看左右是否种植花朵，如果都为0，则当前位置可以设置1，然后计数器+1，最后看计数器的大小是否大于等于n。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canPlaceFlowers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">flowerbed, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; flowerbed.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flowerbed[i] === <span class=\"number\">1</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> pre = i === <span class=\"number\">0</span> ? <span class=\"number\">0</span> : flowerbed[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> next = i === flowerbed.length - <span class=\"number\">1</span> ? <span class=\"number\">0</span> : flowerbed[i + <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre === <span class=\"number\">0</span> &amp;&amp; next === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      flowerbed[i] = <span class=\"number\">1</span></span><br><span class=\"line\">      res++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(flowerbed)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res &gt;= n</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"判断是否为子序列\"><a href=\"#判断是否为子序列\" class=\"headerlink\" title=\"判断是否为子序列\"></a>判断是否为子序列</h1><blockquote>\n<p>LeetCode 392</p>\n<p>s = “abc”, t = “ahbgdc”<br>Return true.</p>\n</blockquote>\n<p>遍历需要判断子序列的序列，对于子序列的每一个字符，在对照序列中依次从左至右遍历，如果找到了，子序列指向下一位，然后对照序列接着遍历，重复此步骤。如果对照序列遍历完成后，子序列也遍历完成了，说明是子序列，否则不是。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isSubsequence = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s, t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> s0 = <span class=\"number\">0</span>, t0 = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (t0 &lt; t.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[s0] === t[t0]) &#123;</span><br><span class=\"line\">      s0++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    t0++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s0 === s.length</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修改一个数变成非递减数组\"><a href=\"#修改一个数变成非递减数组\" class=\"headerlink\" title=\"修改一个数变成非递减数组\"></a>修改一个数变成非递减数组</h1><blockquote>\n<p>LeetCode 665</p>\n<p>Input: [4,2,3]<br>Output: True</p>\n<p>题目描述：判断一个数组能否只修改一个数，使之变成非递减数组。</p>\n</blockquote>\n<p>当 nums[i] &lt; nums[i-1] 时，需要思考，修改哪一个数。理论上两个都可以修改。nums[i] = nums[i-1] or nums[i-1]  = nums[i] 都可以。如果修改当前数的话，会使之变大，影响后序的判断。所以一般情况修改前一个数。</p>\n<p><strong>特殊情况：</strong>当前的数比 nums[i-2] 还要小，由于之前的数已经排序好了，此时再改变 nums[i-1] 会使得 nums[i-1] 变小，所以此时 nums[i] = nums[i-1]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> checkPossibility = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; nums.length &amp;&amp; res &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] &gt;= nums[i - <span class=\"number\">1</span>]) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    res++</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">2</span> &amp;&amp; nums[i] &lt; nums[i - <span class=\"number\">2</span>]) nums[i] = nums[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">else</span> nums[i - <span class=\"number\">1</span>] = nums[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res &lt;= <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"子数组最大的和\"><a href=\"#子数组最大的和\" class=\"headerlink\" title=\"子数组最大的和\"></a>子数组最大的和</h1><blockquote>\n<p>LeetCode 53</p>\n<p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>\n</blockquote>\n<p>当遍历到当前数时，保证之前的最大和是最大的。</p>\n<p>要保证连续数组的最大和，所以负数连续肯定会使最后的值变小。</p>\n<p>所以当之前的连续和为负数时，当遇到当前值时，丢弃掉之前的和，从当前值开始计算。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxSubArray = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> preSum = nums[<span class=\"number\">0</span>], maxSum = preSum</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    preSum = preSum &gt; <span class=\"number\">0</span> ? preSum + nums[i] : nums[i]</span><br><span class=\"line\">    maxSum = <span class=\"built_in\">Math</span>.max(maxSum, preSum)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxSum</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"分隔字符串使同种字符出现在一起\"><a href=\"#分隔字符串使同种字符出现在一起\" class=\"headerlink\" title=\"分隔字符串使同种字符出现在一起\"></a>分隔字符串使同种字符出现在一起</h1><blockquote>\n<p>LeetCode 763</p>\n<p>Input: S = “ababcbacadefegdehijhklij”<br>Output: [9,7,8]</p>\n<p>题目要求：要求分割的数组大小最大。</p>\n</blockquote>\n<p>从左至右遍历字符串，对于每个字符，找到它最后出现的位置。然后对这个区间进行遍历，看它最后出现的位置是否大于之前的字符最后出现的位置，如果大于则扩展这个区间。遍历完成后，同一个字母都值出现在这个区间内。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> partitionLabels = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> firstIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (firstIndex &lt; S.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastIndex = firstIndex</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = firstIndex; i &lt; S.length &amp;&amp; i &lt;= lastIndex; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = S.lastIndexOf(S[i])</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index &gt; lastIndex) &#123;</span><br><span class=\"line\">        lastIndex = index</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.push(lastIndex - firstIndex + <span class=\"number\">1</span>)</span><br><span class=\"line\">    firstIndex = lastIndex + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","categories":["algorithm"],"tags":["LeetCode"]},{"title":"排序","url":"https://xivier.github.io/2019/06/29/排序/","content":"<h1 id=\"快速选择\"><a href=\"#快速选择\" class=\"headerlink\" title=\"快速选择\"></a>快速选择</h1><p>利用了快速排序的思想，求解第 K 个元素的问题。利用的是快速排序的划分思想 partition() 进行实现的。需要先打乱数组，不然最坏的情况复杂度为 O(N^2)。</p>\n<p>快速排序的每次 partition() 过程中都排好一个位置。如果排好的是正数第K个位置，那么它就是第K小的元素。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>预备知识：</p>\n<ul>\n<li>堆是一个完全二叉树</li>\n<li>完全二叉树：除开最后一层，其他层的节点数都达到最大，最后一层的所有节点都集中在左边。</li>\n<li>大根堆：根节点为最大值，每个结点的值大于等于孩子结点的值。</li>\n<li>小根堆：根节点的值为最小值，每个根节点的值都小于等于孩子结点的值。</li>\n<li>堆的存储：用数组来存储。</li>\n<li>对于节点i，子节点为2i+1 与 2i+2</li>\n<li>堆排序算法（以大根堆（heapify）为例）：<ol>\n<li>对每一个非叶子节点，从下至上，从右至左，做 shiftDown 下沉操作。操作后根节点为最大值，将其与最后一个结点交换。</li>\n<li>除开最后一个节点，其余节点继续转化成大根堆，此时根节点为次最大，将其与最后一个结点交换。</li>\n<li>重复2，直到堆中元素个数为1，排序完成。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> swap = <span class=\"function\">(<span class=\"params\">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> shiftDowm = <span class=\"function\">(<span class=\"params\">arr, i, length</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>; j &lt; length; j = j * <span class=\"number\">2</span> + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = arr[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; length &amp;&amp; arr[j + <span class=\"number\">1</span>] &gt; arr[j]) &#123;</span><br><span class=\"line\">      j++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; temp) &#123;</span><br><span class=\"line\">      swap(arr, i, j)</span><br><span class=\"line\">      i = j</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> heapSort = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span> - <span class=\"number\">1</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    shiftDowm(arr, i, arr.length)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    swap(arr, <span class=\"number\">0</span>, i)</span><br><span class=\"line\">    shiftDowm(arr, <span class=\"number\">0</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用于求解第 K 个最小元素问题。可以维护一个大小为K的大根堆。大根堆的堆顶元素即为该堆的最大值。每次遍历新元素时，如果比堆顶元素小，则把堆顶元素去除，将新元素加到堆中，调整堆。遍历完之后，堆里面的K个元素是从小到大排列的，堆顶即为第K个最小元素。</p>\n<p>也可以用于求解第K个最大元素的问题。维护一个K大小的小根堆。</p>\n<h2 id=\"JS-实现堆排序\"><a href=\"#JS-实现堆排序\" class=\"headerlink\" title=\"JS 实现堆排序\"></a>JS 实现堆排序</h2><h1 id=\"Kth-Element\"><a href=\"#Kth-Element\" class=\"headerlink\" title=\"Kth Element\"></a>Kth Element</h1><blockquote>\n<p>LeetCode 215</p>\n<p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5</p>\n<p>题目描述：找出倒数第K大的元素</p>\n</blockquote>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><blockquote>\n<p>时间复杂度 O(NlogN),空间复杂度 O(1)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findKthLargest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">    nums.sort();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[nums.length-k]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>先用自带的排序方法进行排序，然后再取倒数第k个元素</p>\n<h2 id=\"堆-1\"><a href=\"#堆-1\" class=\"headerlink\" title=\"堆\"></a>堆</h2><blockquote>\n<p>时间复杂度 O(NlogK)，空间复杂度 O(K)。</p>\n</blockquote>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><blockquote>\n<p>时间复杂度 O(N)，空间复杂度 O(1)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findKthLargest = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">  k = nums.length - k</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, r = nums.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = partition(nums, l, r)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res === k) <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res &gt; k) r = res - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = res + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums[k]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> partition = <span class=\"function\">(<span class=\"params\">nums, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = i, r = j + <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; j &amp;&amp; nums[++l] &lt; nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (r &gt; i &amp;&amp; nums[--r] &gt; nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    [nums[l], nums[r]] = [nums[r], nums[l]]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  [nums[i], nums[r]] = [nums[r], nums[i]]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过每次划分，找出倒数第k个元素就行。</p>\n<h1 id=\"出现频率最多的-k-个元素\"><a href=\"#出现频率最多的-k-个元素\" class=\"headerlink\" title=\"出现频率最多的 k 个元素\"></a>出现频率最多的 k 个元素</h1><blockquote>\n<p>LeetCode 347</p>\n<p>Given [1,1,1,2,2,3] and k = 2, return [1,2].</p>\n</blockquote>\n<p>设置若干个桶，桶的下标表示出现的频率，即第 i 个桶里存储的数出现的频率为 i。都存到桶里之后，根据桶的频率进行排序，从后往前遍历，最先得到的k个元素即为出现频率最多的k个元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> topKFrequent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> nums) &#123;</span><br><span class=\"line\">    map.set(i, map.get(i) + <span class=\"number\">1</span> || <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sortedArray = [...map.entries()].sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b[<span class=\"number\">1</span>] - a[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">    res.push(sortedArray[i][<span class=\"number\">0</span>])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"按照字符串出现次数对字符串进行排序\"><a href=\"#按照字符串出现次数对字符串进行排序\" class=\"headerlink\" title=\"按照字符串出现次数对字符串进行排序\"></a>按照字符串出现次数对字符串进行排序</h1><blockquote>\n<p>LeetCode 451</p>\n<p>Input:<br>“tree”<br>Output:<br>“eert”</p>\n</blockquote>\n<p>同上题，先用桶存所有字符，按照字符的频率进行排序，从最多频率往最少频率进行打印即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> frequencySort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">    map.set(i, map.get(i) + <span class=\"number\">1</span> || <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [];</span><br><span class=\"line\">  [...map.entries()].sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b[<span class=\"number\">1</span>] - a[<span class=\"number\">1</span>]).forEach(<span class=\"function\"><span class=\"params\">cur</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; cur[<span class=\"number\">1</span>]; i++) &#123;</span><br><span class=\"line\">      res.push(cur[<span class=\"number\">0</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.join(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"荷兰国旗问题\"><a href=\"#荷兰国旗问题\" class=\"headerlink\" title=\"荷兰国旗问题\"></a>荷兰国旗问题</h1><blockquote>\n<p>LeetCode 75 </p>\n<p>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]</p>\n<p>题目描述：按照 0 1 2 顺序进行排序，不能使用原始的排序</p>\n</blockquote>\n<p>运用划分的思想，等于零的放左边，等于二的划分到右边，最后中间就是等于1的了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortColors = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> zero = <span class=\"number\">-1</span>, one = <span class=\"number\">0</span>, two = nums.length</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (one &lt; two) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[one] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      zero++</span><br><span class=\"line\">      [nums[zero], nums[one]] = [nums[one], nums[zero]]</span><br><span class=\"line\">      one++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[one] === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      two--</span><br><span class=\"line\">      [nums[two], nums[one]] = [nums[one], nums[two]]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      one++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","categories":["algorithm"],"tags":["LeetCode"]},{"title":"双指针","url":"https://xivier.github.io/2019/06/28/双指针/","content":"<h1 id=\"1-有序数组的-Two-Sum\"><a href=\"#1-有序数组的-Two-Sum\" class=\"headerlink\" title=\"1. 有序数组的 Two Sum\"></a>1. 有序数组的 Two Sum</h1><p>LeetCode 167</p>\n<p>Input: numbers 有序数组,target 需要求和的值<br>Output: index1,index2  两个值的下标，注意从1开始</p>\n<p>题目描述：在有序数组中寻找两个数，使之和为 target</p>\n<p>使用双指针，一个指针指向较小的元素，一个指针指向较大的元素。小指针从头开始往后遍历，大指针从尾开始往前遍历。</p>\n<ul>\n<li>如果两个指针指向的元素和为 target 则得到了要求的结果</li>\n<li>如果 sum &gt; target 说明结果大了，大指针需要前移</li>\n<li>如果 sum &lt; target 说明结果小了，小指针需要后移</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; numbers</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; target</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> twoSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">numbers, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"number\">0</span>, p2 = numbers.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 &lt; p2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numbers[p1] + numbers[p2] === target) <span class=\"keyword\">return</span> [p1 + <span class=\"number\">1</span>, p2 + <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numbers[p1] + numbers[p2] &lt; target) p1++</span><br><span class=\"line\">    <span class=\"keyword\">else</span> p2--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-两数平方和\"><a href=\"#2-两数平方和\" class=\"headerlink\" title=\"2. 两数平方和\"></a>2. 两数平方和</h1><p>LeetCode 633</p>\n<p>Input: 5<br>Output: True</p>\n<p>题目描述：判断一个数是否是两个数的平方和</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> judgeSquareSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"number\">0</span>, p2 = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.sqrt(c))</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 &lt;= p2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 * p1 + p2 * p2 === c) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p1 * p1 + p2 * p2 &gt; c) p2--</span><br><span class=\"line\">    <span class=\"keyword\">else</span> p1++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-反转字符串中的元音字母\"><a href=\"#3-反转字符串中的元音字母\" class=\"headerlink\" title=\"3. 反转字符串中的元音字母\"></a>3. 反转字符串中的元音字母</h1><p>LeetCode 345</p>\n<p>Input: “LeetCode”<br>Output: “LeoCede”</p>\n<p>解题思路：使用双指针指向待反转的两个元音字母，一个指针从头遍历，一个指针从尾遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reverseVowels = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> VOWELS = &#123; <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'e'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'u'</span>: <span class=\"number\">1</span>, <span class=\"string\">'A'</span>: <span class=\"number\">1</span>, <span class=\"string\">'E'</span>: <span class=\"number\">1</span>, <span class=\"string\">'I'</span>: <span class=\"number\">1</span>, <span class=\"string\">'O'</span>: <span class=\"number\">1</span>, <span class=\"string\">'U'</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = s.split(<span class=\"string\">''</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = arr.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (VOWELS[arr[i]] &amp;&amp; VOWELS[arr[j]]) &#123;</span><br><span class=\"line\">      [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (VOWELS[arr[i]]) j--</span><br><span class=\"line\">    <span class=\"keyword\">else</span> i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.join(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-回文字符串\"><a href=\"#4-回文字符串\" class=\"headerlink\" title=\"4. 回文字符串\"></a>4. 回文字符串</h1><p>LeetCode 680</p>\n<p>Input: “abca”<br>Output: true</p>\n<p>题目描述：可以删除一个字符，判断是否可以构成回文串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> validPalindrome = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = s.length<span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] !== s[j]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> judge(s, i + <span class=\"number\">1</span>, j) || judge(s, i, j - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> judge = <span class=\"function\">(<span class=\"params\">s, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] !== s[j]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">    j--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-归并两个有序数组\"><a href=\"#5-归并两个有序数组\" class=\"headerlink\" title=\"5. 归并两个有序数组\"></a>5. 归并两个有序数组</h1><p>LeetCode 88</p>\n<p>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [4,5,6], n = 3</p>\n<p>Output:<br>[1,2,3,4,5,6]</p>\n<p>题目描述：把结果归并在第一个数组上</p>\n<p>需要从尾部开始遍历，不然结果会覆盖未进行归并的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = m - <span class=\"number\">1</span>, p2 = n - <span class=\"number\">1</span>, mergeIndex = m + n - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 &gt;= <span class=\"number\">0</span> || p2 &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums2[p2--]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p2 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums1[p1--]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums2[p2] &gt;= nums1[p1]) &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums2[p2--]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums1[p1--]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-判断链表是否存在环\"><a href=\"#6-判断链表是否存在环\" class=\"headerlink\" title=\"6. 判断链表是否存在环\"></a>6. 判断链表是否存在环</h1><p>LeetCode 141</p>\n<p>使用双指针，一个指针一次移动一个节点，一个一次移动两个节点，如果存在环，则两个指针一定会相遇。<br>PS: 起始时不能使两个指针指向同一个节点，一前一后不会出问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hasCycle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = head, p2 = head.next</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 !== <span class=\"literal\">null</span> &amp;&amp; p2 !== <span class=\"literal\">null</span> &amp;&amp; p2.next !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 === p2) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    p1 = p1.next</span><br><span class=\"line\">    p2 = p2.next.next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-最长子序列\"><a href=\"#7-最长子序列\" class=\"headerlink\" title=\"7. 最长子序列\"></a>7. 最长子序列</h1><p>LeetCode 524</p>\n<p>Input:<br>s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]</p>\n<p>Output:<br>“apple”</p>\n<p>题目描述：删除 s 中的一些字符，使之能构成 d 列表中的一个字符串，找出能构成的最长字符串，如果字符串长度相同，则取字典序最小的。</p>\n<p>通过删除 s 中的一些字符获得字符串 t，可以认为 t 是 s 的子串序列，我们可以用双指针判断一个字符串是否是另一个字符串的子序列</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findLongestWord = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s, d</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> longestCode = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> cur <span class=\"keyword\">of</span> d) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> l1 = longestCode.length, l2 = cur.length</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1 &gt; l2 || (l1 === l2 &amp;&amp; cur &gt; longestCode))</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSubStr(s, cur)) &#123;</span><br><span class=\"line\">      longestCode = cur</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> longestCode</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isSubStr = <span class=\"function\">(<span class=\"params\">s, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; s.length &amp;&amp; j &lt; target.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] === target[j]) &#123;</span><br><span class=\"line\">      j++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> j === target.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["algorithm"],"tags":["LeetCode"]},{"title":"setTimeout、Promise、Async/Await 的区别","url":"https://xivier.github.io/2019/05/01/setTimeout、Promise、Async和Await的区别/","content":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>总结一下 setTimeout、Promise、Async/Await 的区别</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>我觉得这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。</p>\n<p>其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；</p>\n<p>promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。</p>\n<p>具体看看吧</p>\n<h4 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>)\t<span class=\"comment\">//1. 打印 script start</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'settimeout'</span>)\t<span class=\"comment\">// 4. 打印 settimeout</span></span><br><span class=\"line\">&#125;)\t<span class=\"comment\">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>)\t<span class=\"comment\">//3. 打印 script start</span></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>)</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1 end'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'settimeout'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure>\n\n<p>当JS主线程执行到Promise对象时，</p>\n<ul>\n<li>promise1.then() 的回调就是一个 task</li>\n<li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>\n<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>\n<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>\n</ul>\n<h4 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 start'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 end'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'async2'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\">async1();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure>\n\n<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>\n<p>举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func1())</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://camo.githubusercontent.com/127fb6994c3e219bae33573cc46aab7f97b7367b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303133313137343431333536322e706e67\" target=\"_blank\" rel=\"noopener\"><img src=\"assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303133313137343431333536322e706e67.png\" alt=\"在这里插入图片描述\"></a><br>很显然，func1的运行结果其实就是一个Promise对象。因此我们也可以使用then来处理后续逻辑。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func1().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);  <span class=\"comment\">// 30</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3>","categories":["FrontEnd"],"tags":["JavaScript"]},{"title":"关于map问题","url":"https://xivier.github.io/2019/05/01/map(parseInt)/","content":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>[‘1’, ‘2’, ‘3’].map(parseInt)结果是什么？为什么？</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是<strong>真正的答案是[1, NaN, NaN]</strong>。</p>\n<ul>\n<li>首先让我们回顾一下，map函数的第一个参数callback：</li>\n</ul>\n<p><code>var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])</code><br>这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。</p>\n<ul>\n<li>而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。<br><code>parseInt(string, radix)</code><br>接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。</li>\n<li>了解这两个函数后，我们可以模拟一下运行情况</li>\n</ul>\n<ol>\n<li>parseInt(‘1’, 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1</li>\n<li>parseInt(‘2’, 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</li>\n<li>parseInt(‘3’, 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN</li>\n</ol>\n<ul>\n<li>map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>主要要搞清楚传入的参数，map对数组的每个元素通过回调函数进行映射，第一个参数是该元素，第二个参数是该元素的索引，所以这两个参数传递给map中的回调函数。</p>\n<p>一般我们都是在map中自定义回调函数，然后对数组元素进行操作，这里是使用 parseInt 当做回调函数，parseInt 的第一个参数是被处理的值，第二个表示基数，将 k 进制数转成 10 进制数的，所以 map 时每次的 index 都会当做基数传入。</p>\n","categories":["FrontEnd"],"tags":["JavaScript"]},{"title":"about","url":"https://xivier.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://xivier.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"https://xivier.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://xivier.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://xivier.github.io/tag/index.html","content":"","categories":[],"tags":[]}]