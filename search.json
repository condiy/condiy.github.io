[{"title":"Async/Await 如何通过同步的方式实现异步","url":"https://xivier.github.io/2019/07/22/Async和Await如何通过同步实现异步/","content":"<h3 id=\"前置知识点\"><a href=\"#前置知识点\" class=\"headerlink\" title=\"前置知识点\"></a>前置知识点</h3><ul>\n<li>同步</li>\n<li>异步</li>\n<li>Async/Await</li>\n</ul>\n<p>首先，<strong>js 是单线程的（重复三遍）</strong>，所谓单线程， 通俗的讲就是，一根筋（比喻有点过分，哈哈）执行代码是一行一行的往下走（即所谓的<strong>同步</strong>）， 如果上面的没执行完，就痴痴的等着（是不是很像恋爱中在路边等她/他的你，假装 new 了个对象，啊哈哈哈，调皮一下很开心）， 还是举个 🌰 吧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> d = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1e8</span>; i++) &#123;&#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now() - d); <span class=\"comment\">// 62ms左右</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> d = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Date</span>.now() - d); <span class=\"comment\">// 0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br><span class=\"line\">test1();</span><br></pre></td></tr></table></figure>\n\n<p>上面仅仅是一个 for 循环，而在实际应用中，会有大量的网络请求，它的响应时间是不确定的，这种情况下也要痴痴的等么？显然是不行的，因而 js 设计了异步，即 发起网络请求（诸如 IO 操作，定时器），由于需要等服务器响应，就先不理会，而是去做其他的事儿，等请求返回了结果的时候再说（即<strong>异步</strong>）。 那么如何实现异步呢？其实我们平时已经在大量使用了，那就是 <code>callback</code>，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'http://xxx'</span>,</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>success 作为函数传递过去并不会立即执行，而是等请求成功了才执行，即<strong>回调函数</strong>（callback）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">fs.rename(<span class=\"string\">'旧文件.txt'</span>, <span class=\"string\">'新文件.txt'</span>, err =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'重命名完成'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>和网络请求类似，等到 IO 操作有了结果（无论成功与否）才会执行第三个参数：<code>(err)=&gt;{}</code></p>\n<p>从上面我们就可以看出，实现异步的核心就是回调钩子，将 cb 作为参数传递给异步执行函数，当有了结果后在触发 cb。想了解更多，去看看 <code>event-loop</code> 机制吧。</p>\n<p>至于 async/await 是如何出现的呢，在 es6 之前，大多 js 数项目中会有类似这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax1(url, () =&gt; &#123;</span><br><span class=\"line\">  ajax2(url, () =&gt; &#123;</span><br><span class=\"line\">    ajax3(url, () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">复制代码</span><br></pre></td></tr></table></figure>\n\n<p>这种函数嵌套，大量的回调函数，使代码阅读起来晦涩难懂，不直观，形象的称之为<strong>回调地狱（callback hell）</strong>，所以为了在写法上能更通俗一点，es6+陆续出现了 <code>Promise</code>、<code>Generator</code>、<code>Async/await</code>，力求在写法上简洁明了，可读性强。</p>\n<p>=========================我是分割线==========================</p>\n<p>以上只是铺垫，下面在进入正题 👇，开始说道说道主角：<code>async/await</code></p>\n<p>=========================我是分割线==========================</p>\n<p><code>async/await</code> 是参照 <code>Generator</code> 封装的一套异步处理方案，可以理解为 <code>Generator</code> 的语法糖，</p>\n<p>所以了解 <code>async/await</code> 就不得不讲一讲 <code>Generator</code>,</p>\n<p>而 <code>Generator</code> 又依赖于迭代器<code>Iterator</code>，</p>\n<p>所以就得先讲一讲 <code>Iterator</code>,</p>\n<p>而 <code>Iterator</code> 的思想呢又来源于单向链表，</p>\n<p>终于找到源头了：单向链表</p>\n<h2 id=\"1-单向链表\"><a href=\"#1-单向链表\" class=\"headerlink\" title=\"1. 单向链表\"></a>1. 单向链表</h2><blockquote>\n<p>wiki：链表（Linked list）是一种常见的基础数据结构，是一种<a href=\"https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E7%BA%BF%E6%80%A7%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">线性表</a>，但是并不会按线性的顺序储存数据，而是在每一个节点里存到下一个节点的<a href=\"https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)\" target=\"_blank\" rel=\"noopener\">指针</a>（Pointer）。由于不必须按顺序储存，链表在插入的时候可以达到 o(1)的复杂度，比另一种线性表<a href=\"https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8\" target=\"_blank\" rel=\"noopener\">顺序表</a>快得多，但是查找一个节点或者访问特定编号的节点则需要 o(n)的时间，而顺序表响应的时间复杂度分别是 o(logn)和 o(1)。</p>\n</blockquote>\n<p>总结一下链表优点：</p>\n<ul>\n<li>无需预先分配内存</li>\n<li>插入/删除节点不影响其他节点，效率高（典型的例子：dom 操作）</li>\n</ul>\n<p>单向链表：是链表中最简单的一种，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。 </p>\n<p><img src=\"assets/16bf5d9e13d0e4b1\" alt=\"image\"></p>\n<p> 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接</p>\n<p>单链特点：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</p>\n<p>理解 js 原型链/作用域链的话，理解这个很容易，他们是相通的。编程语言中，数组的长度时固定的，所以数组中的增加和删除比较麻烦，需要频繁的移动数组中的其他元素，而 js 作为一门动态语言，数组本质是一个类似数组的对象，是动态的，不需要预先分配内存</p>\n<p>那么如何设计一个单向链表呢？这个取决于我们需要哪些操作，通常有：</p>\n<ul>\n<li>append(element)：追加节点</li>\n<li>insert(element,index)：在索引位置插入节点</li>\n<li>remove(element)：删除第一个匹配到的节点</li>\n<li>removeAt(index)：删除指定索引节点</li>\n<li>removeAll(element)：删除所有匹配的节点</li>\n<li>get(index)：获取指定索引的节点信息</li>\n<li>set(element,index)：修改指定索引的节点值</li>\n<li>indexOf(element)：获取某节点的索引位置</li>\n<li>clear()：清除所有节点</li>\n<li>length()：返回节点长度</li>\n<li>printf()：打印节点信息</li>\n</ul>\n<p>看到这些方法是不是有些许熟悉，当你用原生 js 或 jq 时常会用上面类似的方法，现在根据上面列出的方法进行实现一个单向链：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节点模型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkNode</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(element, next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._head = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._errorBoundary = <span class=\"keyword\">this</span>._errorBoundary.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._getNodeByIndex = <span class=\"keyword\">this</span>._getNodeByIndex.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.append = <span class=\"keyword\">this</span>.append.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = <span class=\"keyword\">this</span>.insert.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.remove = <span class=\"keyword\">this</span>.remove.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.removeAt = <span class=\"keyword\">this</span>.removeAt.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.removeAll = <span class=\"keyword\">this</span>.removeAll.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getElement = <span class=\"keyword\">this</span>.getElement.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setIndex = <span class=\"keyword\">this</span>.setIndex.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.indexOf = <span class=\"keyword\">this</span>.indexOf.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.clear = <span class=\"keyword\">this</span>.clear.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.length = <span class=\"keyword\">this</span>.length.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.printf = <span class=\"keyword\">this</span>.printf.bind(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 边界检验</span></span><br><span class=\"line\">  _errorBoundary(index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= <span class=\"keyword\">this</span>._size) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"string\">`超出边界(<span class=\"subst\">$&#123;<span class=\"number\">0</span>&#125;</span>~<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>._size&#125;</span>)，目标位置<span class=\"subst\">$&#123;index&#125;</span>不存在！`</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 根据索引获取目标对象</span></span><br><span class=\"line\">  _getNodeByIndex(index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._errorBoundary(index);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = <span class=\"keyword\">this</span>._head;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">      obj = obj.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 追加节点</span></span><br><span class=\"line\">  append(element) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._size === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._head = <span class=\"keyword\">new</span> LinkNode(element, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> obj = <span class=\"keyword\">this</span>._getNodeByIndex(<span class=\"keyword\">this</span>._size - <span class=\"number\">1</span>);</span><br><span class=\"line\">      obj.next = <span class=\"keyword\">new</span> LinkNode(element, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._size++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 在索引位置插入节点</span></span><br><span class=\"line\">  insert(element, index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._head = <span class=\"keyword\">new</span> LinkNode(element, <span class=\"keyword\">this</span>._head);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> obj = <span class=\"keyword\">this</span>._getNodeByIndex(index - <span class=\"number\">1</span>);</span><br><span class=\"line\">      obj.next = <span class=\"keyword\">new</span> LinkNode(element, obj.next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._size++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 删除第一个匹配到的节点</span></span><br><span class=\"line\">  remove(element) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._size &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._head.element == element) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._head.element = <span class=\"keyword\">this</span>._head.next;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._size--;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> temp = <span class=\"keyword\">this</span>._head;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (temp.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp.next.element == element) &#123;</span><br><span class=\"line\">          temp.next = temp.next.next;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>._size--;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 删除指定索引节点</span></span><br><span class=\"line\">  removeAt(index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._errorBoundary(index);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> element = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      element = <span class=\"keyword\">this</span>._head.element;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._head = <span class=\"keyword\">this</span>._head.next;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> prev = <span class=\"keyword\">this</span>._getNodeByIndex(index - <span class=\"number\">1</span>);</span><br><span class=\"line\">      element = prev.next.element;</span><br><span class=\"line\">      prev.next = prev.next.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> element;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 删除所有匹配的节点</span></span><br><span class=\"line\">  removeAll(element) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建虚拟头节点，</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> v_head = <span class=\"keyword\">new</span> LinkNode(<span class=\"literal\">null</span>, <span class=\"keyword\">this</span>._head);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> tempNode = v_head;</span><br><span class=\"line\">    <span class=\"comment\">// let tempEle = null;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tempNode.next) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (tempNode.next.element == element) &#123;</span><br><span class=\"line\">        tempNode.next = tempNode.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._size--;</span><br><span class=\"line\">        <span class=\"comment\">// tempEle = element;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        tempNode = tempNode.next;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._head = v_head.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取指定索引的节点信息</span></span><br><span class=\"line\">  getElement(index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._getNodeByIndex(index).element;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 修改指定索引的节点值</span></span><br><span class=\"line\">  setIndex(element, index) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._errorBoundary(index);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = <span class=\"keyword\">this</span>._getNodeByIndex(index);</span><br><span class=\"line\">    obj.element = element;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取某节点的索引位置</span></span><br><span class=\"line\">  indexOf(element) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = <span class=\"keyword\">this</span>._head;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>._size; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (obj.element == element) &#123;</span><br><span class=\"line\">        index = i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      obj = obj.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 清除所有节点</span></span><br><span class=\"line\">  clear() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._head = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._size = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回节点长度</span></span><br><span class=\"line\">  length() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._size;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 打印节点信息</span></span><br><span class=\"line\">  printf() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = <span class=\"keyword\">this</span>._head;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (obj != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      arr.push(obj.element);</span><br><span class=\"line\">      obj = obj.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> str = arr.join(<span class=\"string\">'-&gt;'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str || <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">obj.append(<span class=\"number\">0</span>);</span><br><span class=\"line\">obj.append(<span class=\"number\">1</span>);</span><br><span class=\"line\">obj.append(<span class=\"number\">2</span>);</span><br><span class=\"line\">obj.printf();</span><br><span class=\"line\"><span class=\"comment\">// \"0-&gt;1-&gt;2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.insert(<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">obj.printf();</span><br><span class=\"line\"><span class=\"comment\">// \"0-&gt;1-&gt;2-&gt;3\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.remove(<span class=\"number\">3</span>);</span><br><span class=\"line\">obj.printf();</span><br><span class=\"line\"><span class=\"comment\">// \"0-&gt;1-&gt;2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.removeAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">obj.printf();</span><br><span class=\"line\"><span class=\"comment\">// \"1-&gt;2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.setIndex(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">obj.printf();</span><br><span class=\"line\"><span class=\"comment\">// \"0-&gt;2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.indexOf(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.length();</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.clear();</span><br><span class=\"line\">obj.printf();</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>通过以上，我假装你明白什么是单向链表，并且能够用代码实现一个单向链表了，下一步开始说一说<strong>迭代器</strong> <code>Iterator</code></p>\n<h2 id=\"2-Iterator\"><a href=\"#2-Iterator\" class=\"headerlink\" title=\"2. Iterator\"></a>2. Iterator</h2><p><code>Iterator</code> 翻译过来就是<strong>迭代器（遍历器）</strong>让我们先来看看它的遍历过程(类似于单向链表)：</p>\n<ul>\n<li>创建一个<strong>指针对象</strong>，指向当前数据结构的起始位置</li>\n<li>第一次调用指针对象的 <code>next</code> 方法，将指针指向数据结构的第一个成员</li>\n<li>第二次调用指针对象的 <code>next</code> 方法，将指针指向数据结构的第二个成员</li>\n<li>不断的调用指针对象的 <code>next</code> 方法，直到它指向数据结构的结束位置</li>\n</ul>\n<p>一个对象要变成可迭代的，必须实现 <code>iterator</code> 方法，即对象（或它原型链上的某个对象）必须有一个名字是 <code>Symbol.iterator</code> 的属性（原生具有该属性的有：字符串、数组、类数组的对象、Set 和 Map）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">属性</th>\n<th align=\"left\">值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">[Symbol.iterator]:</td>\n<td align=\"left\">返回一个对象的无参函数，被返回对象符合迭代器协议</td>\n</tr>\n</tbody></table>\n<p>当一个对象需要被迭代的时候（比如开始用于一个 <code>for..of</code> 循环中），它的 <code>iterator</code> 方法被调用并且无参数，然后返回一个用于在迭代中获得值的迭代器</p>\n<p>迭代器协议：产生一个有限或无限序列的值，并且当所有的值都已经被迭代后，就会有一个默认的返回值</p>\n<p>当一个对象只有满足下述条件才会被认为是一个迭代器：</p>\n<p>它实现了一个 <code>next()</code> 的方法，该方法<strong>必须返回一个对象</strong>,对象有两个必要的属性：</p>\n<ul>\n<li><p><code>done</code>（bool） </p>\n<ul>\n<li>true：迭代器已经超过了可迭代次数。这种情况下,value 的值可以被省略</li>\n<li>如果迭代器可以产生序列中的下一个值，则为 false。这等效于没有指定 done 这个属性</li>\n</ul>\n</li>\n<li><p><code>value</code> 迭代器返回的任何 JavaScript 值。done 为 true 时可省略</p>\n</li>\n</ul>\n<p>根据上面的规则，咱们来自定义一个简单的迭代器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> makeIterator = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    next: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">      nextIndex &lt; arr.length</span><br><span class=\"line\">        ? &#123; <span class=\"attr\">value</span>: arr[nextIndex++], <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">        : &#123; <span class=\"attr\">value</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> it = makeIterator([<span class=\"string\">'人月'</span>, <span class=\"string\">'神话'</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next()); <span class=\"comment\">// &#123; value: \"人月\", done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next()); <span class=\"comment\">// &#123; value: \"神话\", done: false &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(it.next()); <span class=\"comment\">// &#123;value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们还可以自定义一个可迭代对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myIterable = &#123;&#125;;</span><br><span class=\"line\">myIterable[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> myIterable) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//or</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([...myIterable]); <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<p>了解了迭代器，下面可以进一步了解生成器了</p>\n<h2 id=\"3-Generator\"><a href=\"#3-Generator\" class=\"headerlink\" title=\"3. Generator\"></a>3. Generator</h2><p><code>Generator</code>：生成器对象是生成器函数（GeneratorFunction）返回的，它符合<strong>可迭代协议</strong>和<strong>迭代器协议</strong>，既是迭代器也是可迭代对象，可以调用 <code>next</code> 方法，但它不是函数，更不是构造函数</p>\n<p>生成器函数（GeneratorFunction）：</p>\n<blockquote>\n<p>function* name([param[, param[, … param]]]) { statements }</p>\n<ul>\n<li>name：函数名</li>\n<li>param：参数</li>\n<li>statements：js 语句</li>\n</ul>\n</blockquote>\n<p>调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器对象，当这个迭代器的 <code>next()</code> 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现 <code>yield</code> 的位置为止（让执行处于<strong>暂停状</strong>），<code>yield</code> 后紧跟迭代器要返回的值。或者如果用的是 <code>yield*</code>（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器<strong>暂停执行</strong>），调用 <code>next()</code> （再启动）方法时，如果传入了参数，那么这个参数会作为<strong>上一条执行的 yield 语句的返回值</strong>，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">another</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">'人月神话'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span>* another(); <span class=\"comment\">// 移交执行权</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> b = <span class=\"keyword\">yield</span> a; <span class=\"comment\">// a='world' 是 next('world') 传参赋值给了上一个 yidle 'hello' 的左值</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> b; <span class=\"comment\">// b=！ 是 next('！') 传参赋值给了上一个 yidle a 的左值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = gen();</span><br><span class=\"line\">g.next(); <span class=\"comment\">// &#123;value: \"人月神话\", done: false&#125;</span></span><br><span class=\"line\">g.next(); <span class=\"comment\">// &#123;value: \"hello\", done: false&#125;</span></span><br><span class=\"line\">g.next(<span class=\"string\">'world'</span>); <span class=\"comment\">// &#123;value: \"world\", done: false&#125; 将 'world' 赋给上一条 yield 'hello' 的左值，即执行 a='world'，</span></span><br><span class=\"line\">g.next(<span class=\"string\">'!'</span>); <span class=\"comment\">// &#123;value: \"!\", done: false&#125; 将 '!' 赋给上一条 yield a 的左值，即执行 b='!'，返回 b</span></span><br><span class=\"line\">g.next(); <span class=\"comment\">// &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>看到这里，你可能会问，<code>Generator</code> 和 <code>callback</code> 有啥关系，如何处理异步呢？其实二者没有任何关系，我们只是通过一些方式强行的它们产生了关系，才会有 <code>Generator</code> 处理异步</p>\n<p>我们来总结一下 <code>Generator</code> 的本质，暂停，它会让程序执行到指定位置先暂停（<code>yield</code>），然后再启动（<code>next</code>），再暂停（<code>yield</code>），再启动（<code>next</code>），而这个暂停就很容易让它和异步操作产生联系，因为我们在处理异步时：开始异步处理（网络求情、IO 操作），然后暂停一下，等处理完了，再该干嘛干嘛。不过值得注意的是，<strong>js 是单线程的（又重复了三遍）</strong>，异步还是异步，callback 还是 callback，不会因为 <code>Generator</code> 而有任何改变</p>\n<p>下面来看看，用 <code>Generator</code> 实现异步：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promisify = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>).promisify;</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = promisify(fs.readFile);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res1 = <span class=\"keyword\">yield</span> readFile(path.resolve(__dirname, <span class=\"string\">'../data/a.json'</span>), &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">yield</span> readFile(path.resolve(__dirname, <span class=\"string\">'../data/b.json'</span>), &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res2);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = gen();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> g1 = g.next();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'g1:'</span>, g1);</span><br><span class=\"line\"></span><br><span class=\"line\">g1.value</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">res1</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'res1:'</span>, res1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> g2 = g.next(res1);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'g2:'</span>, g2);</span><br><span class=\"line\">    g2.value</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">res2</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'res2:'</span>, res2);</span><br><span class=\"line\">        g.next(res2);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\"><span class=\"params\">err2</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err2);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">err1</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err1);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"comment\">// g1: &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// res1: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   \"a\": 1</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   \"a\": 1</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// g2: &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// res2: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   \"b\": 2</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   \"b\": 2</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上代码是 <code>Generator</code> 和 <code>callback</code> 结合实现的异步，可以看到，仍然需要手动执行 <code>.then</code> 层层添加回调，但由于 <code>next()</code> 方法返回对象 <code>{value: xxx,done: true/false}</code> 所以我们可以简化它，写一个自动执行器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promisify = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>).promisify;</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = promisify(fs.readFile);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">gen</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> g = gen();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = g.next(data);</span><br><span class=\"line\">    <span class=\"comment\">// 深度递归，只要 `Generator` 函数还没执行到最后一步，`next` 函数就调用自身</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.done) <span class=\"keyword\">return</span> res.value;</span><br><span class=\"line\">    res.value.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">      next(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">run(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res1 = <span class=\"keyword\">yield</span> readFile(path.resolve(__dirname, <span class=\"string\">'../data/a.json'</span>), &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1);</span><br><span class=\"line\">  <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   \"a\": 1</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">yield</span> readFile(path.resolve(__dirname, <span class=\"string\">'../data/b.json'</span>), &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res2);</span><br><span class=\"line\">  <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   \"b\": 2</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>说了这么多，怎么还没有到 <code>async/await</code>，客官别急，马上来了（其实我已经漏了一些内容没说：Promise 和 callback 的关系，thunk 函数，co 库，感兴趣的可以去 google 一下。）</p>\n<p>首先，<code>async/await</code> 是 <code>Generator</code> 的语法糖，上面<em>我是分割线</em>下的第一句已经讲过，先来看一下二者的对比：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Generator</span></span><br><span class=\"line\">run(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res1 = <span class=\"keyword\">yield</span> readFile(path.resolve(__dirname, <span class=\"string\">'../data/a.json'</span>), &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">yield</span> readFile(path.resolve(__dirname, <span class=\"string\">'../data/b.json'</span>), &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// async/await</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"keyword\">async</span> ()=&gt;&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res1 = <span class=\"keyword\">await</span> readFile(path.resolve(__dirname, <span class=\"string\">'../data/a.json'</span>), &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res1);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">await</span> readFile(path.resolve(__dirname, <span class=\"string\">'../data/b.json'</span>), &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span> &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res2);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'done'</span>；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> res = readFile();</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，<code>async function</code> 代替了 <code>function*</code>，<code>await</code> 代替了 <code>yield</code>，同时也无需自己手写一个自动执行器 <code>run</code> 了</p>\n<p>现在再来看看<code>async/await</code> 的特点：</p>\n<ul>\n<li>当 <code>await</code> 后面跟的是 Promise 对象时，才会异步执行，其它类型的数据会同步执行</li>\n<li>执行 <code>const res = readFile();</code> 返回的仍然是个 Promise 对象，上面代码中的 <code>return &#39;done&#39;;</code> 会直接被下面 <code>then</code> 函数接收到</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res.then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">// done</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n","categories":["FrontEnd"],"tags":["JavaScript"]},{"title":"","url":"https://xivier.github.io/2019/07/21/编程算法题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/diff算法的优化/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/v-for事件代理/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/下列代码的打印结果/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现深拷贝/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/前端加密/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何将ES6代码转ES5代码/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Proxy实现数据绑定/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/移动零/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/箭头函数和普通函数的区别/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/移动端Retina屏1px像素问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/父子组件生命周期钩子函数执行顺序/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/点调用和括号调用的性能比较/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/比较opacity visibility display的优劣/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Vue中的Object.defineProperty/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/call和allly的区别/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/模拟实现Promise.finally/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/旋转数组/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/输出运行结果/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/for和forEach/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/input防抖/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/react-router问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/数组里取第一个元素和第十万个元素/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/数组编程题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/输出下列代码的执行结果/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/var let const 实现原理/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/打印对称数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/webpack热更新/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/找出链条中的父ID/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/HTTPS中间人攻击/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/设计LazyMan类/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现模糊搜索/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Promise.all/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现token加密/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/两个有序数组中的中位数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/两数之和/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现convert方法/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现add函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/为什么把reducer设计成纯函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现Promise.race/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/修改图片的宽度为300px/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现add.minus功能/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/冒泡排序的实现过程/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/判断是一个正确的网址/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/计算两个数组的交集/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/双向绑定和Vuex是否冲突/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/字符串的匹配/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/埋点请求问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/字符串大小取反/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何实现无缝轮播/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/BFC IFC GFC FFC/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何将销售额存到一个对象里/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何让一个div水平垂直居中/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/sort()排序问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/HTTPS握手过程/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/代码输出什么/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/HTTPS握手中证书校验问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/下列代码执行结果是什么/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/实现一个sleep函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Vue中子组件为何不能修改父组件传递的Prop/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Vue的双向绑定/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/为什么Vuex的mutation和Redux的reducer中不能做异步操作/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/改造代码打印10和20/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/迭代方式实现flatten函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/全局作用域中的const和let/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/BFC/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/模块化发展历程/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/下面代码什么时候会打印1/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/下面代码打印什么内容/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/合并数组问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/浏览器缓存读取规则/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/输出0-9的所有写法/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/为什么不会劫持token/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Virtual DOM问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/浏览器和Node事件循环/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/观察者模式和订阅发布者模式/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/3种判断数组的方法/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/npm模块安装机制/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Redux和Vuex的设计思想/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/重绘和回流/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/一题算法手写题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/React中的setState问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/Promise构造函数的执行/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/TCP三次握手四次挥手/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/一题关于React中的setState笔试题/","content":"<p>F</p>\n","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/JS异步解决方案/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/一题异步笔试题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/http2多路富用/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/重启后TCP状态问题/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/如何实现new/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/深度优先思想和广度优先思想实现拷贝函数/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/ES5和ES6中的继承/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/深度优先遍历和广度优先遍历/","content":"","categories":[],"tags":[]},{"title":"","url":"https://xivier.github.io/2019/07/21/防抖和节流/","content":"","categories":[],"tags":[]},{"title":"React和Vue中的key值问题","url":"https://xivier.github.io/2019/07/01/React和Vue中的key值问题/","content":"","categories":["algorithm"],"tags":["LeetCode"]},{"title":"二分查找","url":"https://xivier.github.io/2019/06/30/二分查找/","content":"<h1 id=\"原始二分查找\"><a href=\"#原始二分查找\" class=\"headerlink\" title=\"原始二分查找\"></a>原始二分查找</h1><blockquote>\n<p>Input : [1,2,3,4,5]<br>key : 3<br>return the index : 2</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binarySearch = <span class=\"function\">(<span class=\"params\">nums, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span>, mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt;= h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] === key) <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; key) h = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度：二分查找，每次将查找区间减半，这种折半特性的时间复杂度为 O(logN)</p>\n<p>返回值：</p>\n<ul>\n<li>-1：表示没有查找到 key。</li>\n<li>l：表示插入到 nums 中的正确位置。</li>\n</ul>\n<p>变种：</p>\n<p>二分查找有很多变种，变种要注意边界值的判断。例如在一个有重复元素中的数组中查找最左边的 key 值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> binarySearch = <span class=\"function\">(<span class=\"params\">nums, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span>, mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key &lt;= nums[mid]) h = mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和上述的实现有什么不同呢？</p>\n<ul>\n<li>赋值表达式变成了 h = mid</li>\n<li>循环语句变成了 l &lt; h</li>\n<li>最后返回的是 l</li>\n</ul>\n<p>因为要找最左的值，所以设置 key &lt;= nums[mid] 时，最左的区间位于 [l,mid] 中，此时将 h = mid，因为 mid 所在的位置也可以是解。</p>\n<p>如果要找最右的值，应当设置 key &gt;= nums[mid] 时，最右的区间位于 [mid,h] 中，此时将 l = mid，因为 mid 所在的位置也可以是解。</p>\n<p>在 h = m 情况下，如果循环条件为 l &lt;= h，那么有可能会出现无限循环无法退出的情况。</p>\n<h1 id=\"求开方\"><a href=\"#求开方\" class=\"headerlink\" title=\"求开方\"></a>求开方</h1><blockquote>\n<p>LeetCode 69</p>\n<p>Input: 4<br>Output: 2<br>Input: 8<br>Output: 2</p>\n<p>如果开方开不尽，开方结果向下取整。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mySqrt = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">1</span>, h = x</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt;= h) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sqrt = <span class=\"built_in\">Math</span>.floor(x / mid)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sqrt === mid) <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sqrt &lt; mid) h = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>通过二分查找来查找开方数 sqrt，因为 sqrt * sqrt = x。所以可以对 1 -  x 的区间进行二分查找。</p>\n<p>本题关键是最后的返回值，退出循环时， l &gt; h，当开方开不尽的时候，结果就是 h ，为什么是 h 不是 l 呢？循环退出时， h 总是比 l 小1，由于本题要向下取整，所以取 h。</p>\n<h1 id=\"大于给定元素的最小元素\"><a href=\"#大于给定元素的最小元素\" class=\"headerlink\" title=\"大于给定元素的最小元素\"></a>大于给定元素的最小元素</h1><blockquote>\n<p>LeetCode 744</p>\n<p>Input:<br>letters = [“c”, “f”, “j”]<br>target = “d”<br>Output: “f”<br>Input:<br>letters = [“c”, “f”, “j”]<br>target = “k”<br>Output: “c”</p>\n<p>题目描述：给定一个有序的字符数组 letters，再给定一个字符 target，要求在 letters 中查找大于 target 的最小字符。如果找不到就返回第一个元素。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nextGreatestLetter = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">letters, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = letters.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt;= h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (letters[mid] &lt;= target) &#123;</span><br><span class=\"line\">      l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      h = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l &lt; letters.length ? letters[l] : letters[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于字符数组是有序的，根据有序数组查找指定字符，想到用二分查找。</p>\n<h1 id=\"有序数组的-Single-Element\"><a href=\"#有序数组的-Single-Element\" class=\"headerlink\" title=\"有序数组的 Single Element\"></a>有序数组的 Single Element</h1><blockquote>\n<p>LeetCode 540</p>\n<p>Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]<br>Output: 2</p>\n<p>一个有序数组只有一个数不出现两次，找出这个数</p>\n</blockquote>\n<p>时间复杂度要求 O(logN)，因此很容易想到用二分查找。</p>\n<p>假设index 为 Single Element 出现在数组中的位置。在 index 之后，数组原来的下标状态将会改变。如果 m 为偶数， m+1 &lt; index，那么，nums[m] = nums[m+1]；m+1 &gt;=index，那么 nums[m] != nums[m+1]</p>\n<p>所以可知， 如果 nums[m] === nums[m+1] 则 target 所在的区间为 [m+2,h]；如果 nums[m] !=== nums[m+1] 则 target 所在区间为 [l,m]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> singleNonDuplicate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span>, mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mid % <span class=\"number\">2</span> === <span class=\"number\">1</span>) mid -= <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] === nums[mid + <span class=\"number\">1</span>]) l = mid + <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> h = mid</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums[h]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第一个错误的版本\"><a href=\"#第一个错误的版本\" class=\"headerlink\" title=\"第一个错误的版本\"></a>第一个错误的版本</h1><blockquote>\n<p>LeetCode 278</p>\n<p>题目描述：找到一个错误版本。</p>\n<p>如果第 mid 个版本出错，那么第一个错误版本所在区间为 [l,mid]，此时 h=mid；否认第一个错误区间为 [mid+1,h],此时 l=mid+1</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> solution = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">isBadVersion</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;integer&#125; n Total versions</span></span><br><span class=\"line\"><span class=\"comment\">     * @return &#123;integer&#125; The first bad version</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> l = <span class=\"number\">1</span>, h = n, mid</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">            mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isBadVersion(mid)) h = mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"旋转数组的最小数字\"><a href=\"#旋转数组的最小数字\" class=\"headerlink\" title=\"旋转数组的最小数字\"></a>旋转数组的最小数字</h1><blockquote>\n<p>LeetCode 153</p>\n<p>Input: [3,4,5,1,2],<br>Output: 1</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findMin = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &gt;= nums[h]) l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> h = mid</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums[l]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果第 mid 个数字比 nums[h]小，则最小数字在  [l,mid] 之中， h=mid，否则最小数字在 [mid+1,h]之中。</p>\n<h1 id=\"查找区间\"><a href=\"#查找区间\" class=\"headerlink\" title=\"查找区间\"></a>查找区间</h1><blockquote>\n<p>LeetCode 34</p>\n<p>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]<br>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchRange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> first = binarySearch(nums, target)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> last = binarySearch(nums, target + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nums[first] !== target) <span class=\"keyword\">return</span> [<span class=\"number\">-1</span>, <span class=\"number\">-1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [first, <span class=\"built_in\">Math</span>.max(last, first)]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> binarySearch = <span class=\"function\">(<span class=\"params\">nums, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, h = nums.length</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mid</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; h) &#123;</span><br><span class=\"line\">    mid = <span class=\"built_in\">Math</span>.floor(l + (h - l) / <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[mid] &gt;= target) h = mid</span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要查找的值比当前值小或者相等，则要查找的值的最左边在 [l,mid] 此时 h = mid，否则，要查找的值在 [mid+1,h]。</p>\n","categories":["algorithm"],"tags":["LeetCode"]},{"title":"贪心思想","url":"https://xivier.github.io/2019/06/30/贪心思想/","content":"<p>贪心思想的原理：保证每次操作都是局部最优，并且最后的结果是全局最优的。</p>\n<h1 id=\"分配饼干\"><a href=\"#分配饼干\" class=\"headerlink\" title=\"分配饼干\"></a>分配饼干</h1><blockquote>\n<p>LeetCode 455</p>\n<p>Input: [1,2], [1,2,3]<br>Output: 2</p>\n<p>题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于等于孩子的满足度才能满足孩子。每个孩子只能分配一块饼干。</p>\n</blockquote>\n<p>给每个孩子的饼干应该尽可能小，但是又能满足他。这样满足度大的饼干就能满足满足度比较大的孩子。就可以保证满足最多的孩子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findContentChildren = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">g, s</span>) </span>&#123;</span><br><span class=\"line\">  g.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  s.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> gi = <span class=\"number\">0</span>, si = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (gi &lt; g.length &amp;&amp; si &lt; s.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[si] &gt;= g[gi]) &#123;</span><br><span class=\"line\">      gi++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    si++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> gi</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"不重叠的区间个数\"><a href=\"#不重叠的区间个数\" class=\"headerlink\" title=\"不重叠的区间个数\"></a>不重叠的区间个数</h1><blockquote>\n<p>LeetCode 435</p>\n<p>Input: [ [1,2], [1,2], [1,2] ]<br>Output: 2</p>\n<p>题目描述：计算一组区间要做到不重叠，需要移除的区间个数。要做到移除的区间个数最小，即要计算最多能组成的不重叠区间数。然后用总区间减去不重叠的区间数。</p>\n</blockquote>\n<p>每次选择，区间结尾如果小于等于区间开头，则不重叠。区间的结尾越小，留给后面的区间的空间越大，可以选择的区间个数也越大。</p>\n<p>所以对区间的结尾进行排序，每次选择结尾最小，并且和前一个不重叠的区间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> eraseOverlapIntervals = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">intervals</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (intervals.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  intervals.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>])</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>, end = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end &gt; intervals[i][<span class=\"number\">0</span>]) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    end = intervals[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">    res++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> intervals.length - res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>一定要考虑边界值。当传入空数组时，返回0。</p>\n<h1 id=\"投飞镖刺破气球\"><a href=\"#投飞镖刺破气球\" class=\"headerlink\" title=\"投飞镖刺破气球\"></a>投飞镖刺破气球</h1><blockquote>\n<p>LeetCode 452</p>\n<p>Input:<br>[[10,16], [2,8], [1,6], [7,12]]<br>Output:<br>2</p>\n<p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直坐标轴投向，使得路径上的气球都被刺破。求解最小的投飞镖次数使得所有气球都被刺破。</p>\n</blockquote>\n<p>计算不重叠的区间个数，区别是边界也是重叠区间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findMinArrowShots = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">points</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (points.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  points.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>])</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>, end = points[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; points.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (end &gt;= points[i][<span class=\"number\">0</span>]) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    res++</span><br><span class=\"line\">    end = points[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"根据身高和序号重组队列\"><a href=\"#根据身高和序号重组队列\" class=\"headerlink\" title=\"根据身高和序号重组队列\"></a>根据身高和序号重组队列</h1><blockquote>\n<p>LeetCode 406</p>\n<p>Input:<br>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]<br>Output:<br>[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p>\n<p>题目描述：每个学生用两个分量表示（h,k）,h表示身高，k表示前面有&gt;=k个学生的身高和他一样高。</p>\n<p>因为包保证前面有k个学生的身高大于等于他本身。所以先h降序排列，k升序排列。每个学生都插入到底k个位置，保证前面有k个学生身高大于等于他。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reconstructQueue = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">people</span>) </span>&#123;</span><br><span class=\"line\">  people.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] === b[<span class=\"number\">0</span>] ? a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>] : b[<span class=\"number\">0</span>] - a[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(people)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> people) &#123;</span><br><span class=\"line\">    res.splice(i[<span class=\"number\">1</span>], <span class=\"number\">0</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"买卖股票最大的收益-I\"><a href=\"#买卖股票最大的收益-I\" class=\"headerlink\" title=\"买卖股票最大的收益 I\"></a>买卖股票最大的收益 I</h1><blockquote>\n<p>LeetCode 121</p>\n<p>题目描述：只进行一次股票交易，买入卖出求最大利益。</p>\n</blockquote>\n<p>记录前面的最小价格，然后将整个最小价格作为买入价格。将当前价格作为售出价格，查看当前收益是不是最大收益。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxProfit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">prices</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> minPrice = prices[<span class=\"number\">0</span>]</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> rase = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &lt; minPrice) minPrice = prices[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &gt; minPrice) rase = prices[i] - minPrice</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rase &gt; res) res = rase</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"买卖股票的最大收益-II\"><a href=\"#买卖股票的最大收益-II\" class=\"headerlink\" title=\"买卖股票的最大收益 II\"></a>买卖股票的最大收益 II</h1><blockquote>\n<p>LeetCode 122</p>\n<p>题目描述：可以进行多次交易，但是交易不能交叉。即买入股票，卖了之后才买再买。求最大利益</p>\n</blockquote>\n<p>只要当前的金额大于前一项的金额，即可看做获得收益。即每次到当前金额时保证之前的利润都是最大的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxProfit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">prices</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prices[i] &gt; prices[i - <span class=\"number\">1</span>]) res += prices[i] - prices[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"种植花朵\"><a href=\"#种植花朵\" class=\"headerlink\" title=\"种植花朵\"></a>种植花朵</h1><blockquote>\n<p>LeetCode 605</p>\n<p>Input: flowerbed = [1,0,0,0,1], n = 1<br>Output: True</p>\n<p>题目描述：1 表示种植了花朵，0 表示没有种植花朵。花朵之间至少间隔一个单位的间隙。求解是否能种下 n 朵花</p>\n</blockquote>\n<p>需要考虑边界，在第一个和最后个位置时考虑左边和右边可以看做 0 ，没有种植花朵。其他位置时，看左右是否种植花朵，如果都为0，则当前位置可以设置1，然后计数器+1，最后看计数器的大小是否大于等于n。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canPlaceFlowers = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">flowerbed, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; flowerbed.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (flowerbed[i] === <span class=\"number\">1</span>) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> pre = i === <span class=\"number\">0</span> ? <span class=\"number\">0</span> : flowerbed[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">let</span> next = i === flowerbed.length - <span class=\"number\">1</span> ? <span class=\"number\">0</span> : flowerbed[i + <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pre === <span class=\"number\">0</span> &amp;&amp; next === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      flowerbed[i] = <span class=\"number\">1</span></span><br><span class=\"line\">      res++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(flowerbed)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res &gt;= n</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"判断是否为子序列\"><a href=\"#判断是否为子序列\" class=\"headerlink\" title=\"判断是否为子序列\"></a>判断是否为子序列</h1><blockquote>\n<p>LeetCode 392</p>\n<p>s = “abc”, t = “ahbgdc”<br>Return true.</p>\n</blockquote>\n<p>遍历需要判断子序列的序列，对于子序列的每一个字符，在对照序列中依次从左至右遍历，如果找到了，子序列指向下一位，然后对照序列接着遍历，重复此步骤。如果对照序列遍历完成后，子序列也遍历完成了，说明是子序列，否则不是。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isSubsequence = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s, t</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> s0 = <span class=\"number\">0</span>, t0 = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (t0 &lt; t.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[s0] === t[t0]) &#123;</span><br><span class=\"line\">      s0++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    t0++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s0 === s.length</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修改一个数变成非递减数组\"><a href=\"#修改一个数变成非递减数组\" class=\"headerlink\" title=\"修改一个数变成非递减数组\"></a>修改一个数变成非递减数组</h1><blockquote>\n<p>LeetCode 665</p>\n<p>Input: [4,2,3]<br>Output: True</p>\n<p>题目描述：判断一个数组能否只修改一个数，使之变成非递减数组。</p>\n</blockquote>\n<p>当 nums[i] &lt; nums[i-1] 时，需要思考，修改哪一个数。理论上两个都可以修改。nums[i] = nums[i-1] or nums[i-1]  = nums[i] 都可以。如果修改当前数的话，会使之变大，影响后序的判断。所以一般情况修改前一个数。</p>\n<p><strong>特殊情况：</strong>当前的数比 nums[i-2] 还要小，由于之前的数已经排序好了，此时再改变 nums[i-1] 会使得 nums[i-1] 变小，所以此时 nums[i] = nums[i-1]</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> checkPossibility = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; nums.length &amp;&amp; res &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[i] &gt;= nums[i - <span class=\"number\">1</span>]) <span class=\"keyword\">continue</span></span><br><span class=\"line\">    res++</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">2</span> &amp;&amp; nums[i] &lt; nums[i - <span class=\"number\">2</span>]) nums[i] = nums[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">else</span> nums[i - <span class=\"number\">1</span>] = nums[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res &lt;= <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"子数组最大的和\"><a href=\"#子数组最大的和\" class=\"headerlink\" title=\"子数组最大的和\"></a>子数组最大的和</h1><blockquote>\n<p>LeetCode 53</p>\n<p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br>the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>\n</blockquote>\n<p>当遍历到当前数时，保证之前的最大和是最大的。</p>\n<p>要保证连续数组的最大和，所以负数连续肯定会使最后的值变小。</p>\n<p>所以当之前的连续和为负数时，当遇到当前值时，丢弃掉之前的和，从当前值开始计算。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> maxSubArray = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> preSum = nums[<span class=\"number\">0</span>], maxSum = preSum</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">    preSum = preSum &gt; <span class=\"number\">0</span> ? preSum + nums[i] : nums[i]</span><br><span class=\"line\">    maxSum = <span class=\"built_in\">Math</span>.max(maxSum, preSum)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> maxSum</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"分隔字符串使同种字符出现在一起\"><a href=\"#分隔字符串使同种字符出现在一起\" class=\"headerlink\" title=\"分隔字符串使同种字符出现在一起\"></a>分隔字符串使同种字符出现在一起</h1><blockquote>\n<p>LeetCode 763</p>\n<p>Input: S = “ababcbacadefegdehijhklij”<br>Output: [9,7,8]</p>\n<p>题目要求：要求分割的数组大小最大。</p>\n</blockquote>\n<p>从左至右遍历字符串，对于每个字符，找到它最后出现的位置。然后对这个区间进行遍历，看它最后出现的位置是否大于之前的字符最后出现的位置，如果大于则扩展这个区间。遍历完成后，同一个字母都值出现在这个区间内。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> partitionLabels = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">S</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> firstIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (firstIndex &lt; S.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastIndex = firstIndex</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = firstIndex; i &lt; S.length &amp;&amp; i &lt;= lastIndex; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> index = S.lastIndexOf(S[i])</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (index &gt; lastIndex) &#123;</span><br><span class=\"line\">        lastIndex = index</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res.push(lastIndex - firstIndex + <span class=\"number\">1</span>)</span><br><span class=\"line\">    firstIndex = lastIndex + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","categories":["algorithm"],"tags":["LeetCode"]},{"title":"排序","url":"https://xivier.github.io/2019/06/29/排序/","content":"<h1 id=\"快速选择\"><a href=\"#快速选择\" class=\"headerlink\" title=\"快速选择\"></a>快速选择</h1><p>利用了快速排序的思想，求解第 K 个元素的问题。利用的是快速排序的划分思想 partition() 进行实现的。需要先打乱数组，不然最坏的情况复杂度为 O(N^2)。</p>\n<p>快速排序的每次 partition() 过程中都排好一个位置。如果排好的是正数第K个位置，那么它就是第K小的元素。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>预备知识：</p>\n<ul>\n<li>堆是一个完全二叉树</li>\n<li>完全二叉树：除开最后一层，其他层的节点数都达到最大，最后一层的所有节点都集中在左边。</li>\n<li>大根堆：根节点为最大值，每个结点的值大于等于孩子结点的值。</li>\n<li>小根堆：根节点的值为最小值，每个根节点的值都小于等于孩子结点的值。</li>\n<li>堆的存储：用数组来存储。</li>\n<li>对于节点i，子节点为2i+1 与 2i+2</li>\n<li>堆排序算法（以大根堆（heapify）为例）：<ol>\n<li>对每一个非叶子节点，从下至上，从右至左，做 shiftDown 下沉操作。操作后根节点为最大值，将其与最后一个结点交换。</li>\n<li>除开最后一个节点，其余节点继续转化成大根堆，此时根节点为次最大，将其与最后一个结点交换。</li>\n<li>重复2，直到堆中元素个数为1，排序完成。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> swap = <span class=\"function\">(<span class=\"params\">arr, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> shiftDowm = <span class=\"function\">(<span class=\"params\">arr, i, length</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>; j &lt; length; j = j * <span class=\"number\">2</span> + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = arr[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; length &amp;&amp; arr[j + <span class=\"number\">1</span>] &gt; arr[j]) &#123;</span><br><span class=\"line\">      j++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt; temp) &#123;</span><br><span class=\"line\">      swap(arr, i, j)</span><br><span class=\"line\">      i = j</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> heapSort = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span> - <span class=\"number\">1</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    shiftDowm(arr, i, arr.length)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = arr.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    swap(arr, <span class=\"number\">0</span>, i)</span><br><span class=\"line\">    shiftDowm(arr, <span class=\"number\">0</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用于求解第 K 个最小元素问题。可以维护一个大小为K的大根堆。大根堆的堆顶元素即为该堆的最大值。每次遍历新元素时，如果比堆顶元素小，则把堆顶元素去除，将新元素加到堆中，调整堆。遍历完之后，堆里面的K个元素是从小到大排列的，堆顶即为第K个最小元素。</p>\n<p>也可以用于求解第K个最大元素的问题。维护一个K大小的小根堆。</p>\n<h2 id=\"JS-实现堆排序\"><a href=\"#JS-实现堆排序\" class=\"headerlink\" title=\"JS 实现堆排序\"></a>JS 实现堆排序</h2><h1 id=\"Kth-Element\"><a href=\"#Kth-Element\" class=\"headerlink\" title=\"Kth Element\"></a>Kth Element</h1><blockquote>\n<p>LeetCode 215</p>\n<p>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5</p>\n<p>题目描述：找出倒数第K大的元素</p>\n</blockquote>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><blockquote>\n<p>时间复杂度 O(NlogN),空间复杂度 O(1)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findKthLargest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">    nums.sort();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[nums.length-k]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>先用自带的排序方法进行排序，然后再取倒数第k个元素</p>\n<h2 id=\"堆-1\"><a href=\"#堆-1\" class=\"headerlink\" title=\"堆\"></a>堆</h2><blockquote>\n<p>时间复杂度 O(NlogK)，空间复杂度 O(K)。</p>\n</blockquote>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><blockquote>\n<p>时间复杂度 O(N)，空间复杂度 O(1)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findKthLargest = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">  k = nums.length - k</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = <span class=\"number\">0</span>, r = nums.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = partition(nums, l, r)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res === k) <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res &gt; k) r = res - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> l = res + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums[k]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> partition = <span class=\"function\">(<span class=\"params\">nums, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> l = i, r = j + <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; j &amp;&amp; nums[++l] &lt; nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (r &gt; i &amp;&amp; nums[--r] &gt; nums[i]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    [nums[l], nums[r]] = [nums[r], nums[l]]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  [nums[i], nums[r]] = [nums[r], nums[i]]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过每次划分，找出倒数第k个元素就行。</p>\n<h1 id=\"出现频率最多的-k-个元素\"><a href=\"#出现频率最多的-k-个元素\" class=\"headerlink\" title=\"出现频率最多的 k 个元素\"></a>出现频率最多的 k 个元素</h1><blockquote>\n<p>LeetCode 347</p>\n<p>Given [1,1,1,2,2,3] and k = 2, return [1,2].</p>\n</blockquote>\n<p>设置若干个桶，桶的下标表示出现的频率，即第 i 个桶里存储的数出现的频率为 i。都存到桶里之后，根据桶的频率进行排序，从后往前遍历，最先得到的k个元素即为出现频率最多的k个元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> topKFrequent = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums, k</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> nums) &#123;</span><br><span class=\"line\">    map.set(i, map.get(i) + <span class=\"number\">1</span> || <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sortedArray = [...map.entries()].sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b[<span class=\"number\">1</span>] - a[<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">    res.push(sortedArray[i][<span class=\"number\">0</span>])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"按照字符串出现次数对字符串进行排序\"><a href=\"#按照字符串出现次数对字符串进行排序\" class=\"headerlink\" title=\"按照字符串出现次数对字符串进行排序\"></a>按照字符串出现次数对字符串进行排序</h1><blockquote>\n<p>LeetCode 451</p>\n<p>Input:<br>“tree”<br>Output:<br>“eert”</p>\n</blockquote>\n<p>同上题，先用桶存所有字符，按照字符的频率进行排序，从最多频率往最少频率进行打印即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> frequencySort = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</span><br><span class=\"line\">    map.set(i, map.get(i) + <span class=\"number\">1</span> || <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [];</span><br><span class=\"line\">  [...map.entries()].sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b[<span class=\"number\">1</span>] - a[<span class=\"number\">1</span>]).forEach(<span class=\"function\"><span class=\"params\">cur</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; cur[<span class=\"number\">1</span>]; i++) &#123;</span><br><span class=\"line\">      res.push(cur[<span class=\"number\">0</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.join(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"荷兰国旗问题\"><a href=\"#荷兰国旗问题\" class=\"headerlink\" title=\"荷兰国旗问题\"></a>荷兰国旗问题</h1><blockquote>\n<p>LeetCode 75 </p>\n<p>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]</p>\n<p>题目描述：按照 0 1 2 顺序进行排序，不能使用原始的排序</p>\n</blockquote>\n<p>运用划分的思想，等于零的放左边，等于二的划分到右边，最后中间就是等于1的了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortColors = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> zero = <span class=\"number\">-1</span>, one = <span class=\"number\">0</span>, two = nums.length</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (one &lt; two) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nums[one] === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      zero++</span><br><span class=\"line\">      [nums[zero], nums[one]] = [nums[one], nums[zero]]</span><br><span class=\"line\">      one++</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[one] === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      two--</span><br><span class=\"line\">      [nums[two], nums[one]] = [nums[one], nums[two]]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      one++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> nums</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","categories":["algorithm"],"tags":["LeetCode"]},{"title":"双指针","url":"https://xivier.github.io/2019/06/28/双指针/","content":"<h1 id=\"1-有序数组的-Two-Sum\"><a href=\"#1-有序数组的-Two-Sum\" class=\"headerlink\" title=\"1. 有序数组的 Two Sum\"></a>1. 有序数组的 Two Sum</h1><p>LeetCode 167</p>\n<p>Input: numbers 有序数组,target 需要求和的值<br>Output: index1,index2  两个值的下标，注意从1开始</p>\n<p>题目描述：在有序数组中寻找两个数，使之和为 target</p>\n<p>使用双指针，一个指针指向较小的元素，一个指针指向较大的元素。小指针从头开始往后遍历，大指针从尾开始往前遍历。</p>\n<ul>\n<li>如果两个指针指向的元素和为 target 则得到了要求的结果</li>\n<li>如果 sum &gt; target 说明结果大了，大指针需要前移</li>\n<li>如果 sum &lt; target 说明结果小了，小指针需要后移</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number[]&#125; numbers</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;number&#125; target</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;number[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> twoSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">numbers, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"number\">0</span>, p2 = numbers.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 &lt; p2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numbers[p1] + numbers[p2] === target) <span class=\"keyword\">return</span> [p1 + <span class=\"number\">1</span>, p2 + <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (numbers[p1] + numbers[p2] &lt; target) p1++</span><br><span class=\"line\">    <span class=\"keyword\">else</span> p2--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-两数平方和\"><a href=\"#2-两数平方和\" class=\"headerlink\" title=\"2. 两数平方和\"></a>2. 两数平方和</h1><p>LeetCode 633</p>\n<p>Input: 5<br>Output: True</p>\n<p>题目描述：判断一个数是否是两个数的平方和</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> judgeSquareSum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = <span class=\"number\">0</span>, p2 = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.sqrt(c))</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 &lt;= p2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 * p1 + p2 * p2 === c) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p1 * p1 + p2 * p2 &gt; c) p2--</span><br><span class=\"line\">    <span class=\"keyword\">else</span> p1++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-反转字符串中的元音字母\"><a href=\"#3-反转字符串中的元音字母\" class=\"headerlink\" title=\"3. 反转字符串中的元音字母\"></a>3. 反转字符串中的元音字母</h1><p>LeetCode 345</p>\n<p>Input: “LeetCode”<br>Output: “LeoCede”</p>\n<p>解题思路：使用双指针指向待反转的两个元音字母，一个指针从头遍历，一个指针从尾遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reverseVowels = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> VOWELS = &#123; <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'e'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'u'</span>: <span class=\"number\">1</span>, <span class=\"string\">'A'</span>: <span class=\"number\">1</span>, <span class=\"string\">'E'</span>: <span class=\"number\">1</span>, <span class=\"string\">'I'</span>: <span class=\"number\">1</span>, <span class=\"string\">'O'</span>: <span class=\"number\">1</span>, <span class=\"string\">'U'</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = s.split(<span class=\"string\">''</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = arr.length - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (VOWELS[arr[i]] &amp;&amp; VOWELS[arr[j]]) &#123;</span><br><span class=\"line\">      [arr[i], arr[j]] = [arr[j], arr[i]]</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (VOWELS[arr[i]]) j--</span><br><span class=\"line\">    <span class=\"keyword\">else</span> i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.join(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-回文字符串\"><a href=\"#4-回文字符串\" class=\"headerlink\" title=\"4. 回文字符串\"></a>4. 回文字符串</h1><p>LeetCode 680</p>\n<p>Input: “abca”<br>Output: true</p>\n<p>题目描述：可以删除一个字符，判断是否可以构成回文串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> validPalindrome = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = s.length<span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] !== s[j]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> judge(s, i + <span class=\"number\">1</span>, j) || judge(s, i, j - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i++</span><br><span class=\"line\">      j--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> judge = <span class=\"function\">(<span class=\"params\">s, i, j</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; j) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] !== s[j]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">    j--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-归并两个有序数组\"><a href=\"#5-归并两个有序数组\" class=\"headerlink\" title=\"5. 归并两个有序数组\"></a>5. 归并两个有序数组</h1><p>LeetCode 88</p>\n<p>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [4,5,6], n = 3</p>\n<p>Output:<br>[1,2,3,4,5,6]</p>\n<p>题目描述：把结果归并在第一个数组上</p>\n<p>需要从尾部开始遍历，不然结果会覆盖未进行归并的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = m - <span class=\"number\">1</span>, p2 = n - <span class=\"number\">1</span>, mergeIndex = m + n - <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 &gt;= <span class=\"number\">0</span> || p2 &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums2[p2--]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p2 &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums1[p1--]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums2[p2] &gt;= nums1[p1]) &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums2[p2--]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      nums1[mergeIndex--] = nums1[p1--]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-判断链表是否存在环\"><a href=\"#6-判断链表是否存在环\" class=\"headerlink\" title=\"6. 判断链表是否存在环\"></a>6. 判断链表是否存在环</h1><p>LeetCode 141</p>\n<p>使用双指针，一个指针一次移动一个节点，一个一次移动两个节点，如果存在环，则两个指针一定会相遇。<br>PS: 起始时不能使两个指针指向同一个节点，一前一后不会出问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hasCycle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">head</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (head === <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> p1 = head, p2 = head.next</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (p1 !== <span class=\"literal\">null</span> &amp;&amp; p2 !== <span class=\"literal\">null</span> &amp;&amp; p2.next !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p1 === p2) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    p1 = p1.next</span><br><span class=\"line\">    p2 = p2.next.next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-最长子序列\"><a href=\"#7-最长子序列\" class=\"headerlink\" title=\"7. 最长子序列\"></a>7. 最长子序列</h1><p>LeetCode 524</p>\n<p>Input:<br>s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]</p>\n<p>Output:<br>“apple”</p>\n<p>题目描述：删除 s 中的一些字符，使之能构成 d 列表中的一个字符串，找出能构成的最长字符串，如果字符串长度相同，则取字典序最小的。</p>\n<p>通过删除 s 中的一些字符获得字符串 t，可以认为 t 是 s 的子串序列，我们可以用双指针判断一个字符串是否是另一个字符串的子序列</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> findLongestWord = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s, d</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> longestCode = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> cur <span class=\"keyword\">of</span> d) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> l1 = longestCode.length, l2 = cur.length</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1 &gt; l2 || (l1 === l2 &amp;&amp; cur &gt; longestCode))</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isSubStr(s, cur)) &#123;</span><br><span class=\"line\">      longestCode = cur</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> longestCode</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isSubStr = <span class=\"function\">(<span class=\"params\">s, target</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &lt; s.length &amp;&amp; j &lt; target.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] === target[j]) &#123;</span><br><span class=\"line\">      j++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> j === target.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["algorithm"],"tags":["LeetCode"]},{"title":"详解Set、Map、WeakSet 和 WeakMap","url":"https://xivier.github.io/2019/06/22/Set、Map、WeakSet、WeakMap/","content":"<p>Set 和 Map 主要的应用场景在于 <strong>数据重组</strong> 和 <strong>数据储存</strong></p>\n<p>Set 是一种叫做<strong>集合</strong>的数据结构，Map 是一种叫做<strong>字典</strong>的数据结构</p>\n<h3 id=\"集合（Set）\"><a href=\"#集合（Set）\" class=\"headerlink\" title=\"集合（Set）\"></a>集合（Set）</h3><p>ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</p>\n<p><strong>Set 本身是一种构造函数，用来生成 Set 数据结构。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([iterable])</span><br></pre></td></tr></table></figure>\n\n<p>举个例子：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const s = new Set()</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>].forEach(x =&gt; s.add(x))</span><br><span class=\"line\"></span><br><span class=\"line\">for (let i of s) &#123;</span><br><span class=\"line\">    console.log(i)\t<span class=\"comment\">// 1 2 3 4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 去重数组的重复对象</span></span><br><span class=\"line\">let arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">[... new Set(arr)]\t<span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<p>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。</p>\n<p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于<strong>精确相等</strong>运算符（<code>===</code>），主要的区别是<strong><code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</strong></p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Set();</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = NaN;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = NaN;</span><br><span class=\"line\"><span class=\"keyword\">set</span>.<span class=\"keyword\">add</span>(a);</span><br><span class=\"line\"><span class=\"keyword\">set</span>.<span class=\"keyword\">add</span>(b);</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"comment\">// Set &#123;NaN&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> set1 = <span class=\"keyword\">new</span> Set()</span><br><span class=\"line\">set1.<span class=\"keyword\">add</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\">set1.<span class=\"keyword\">add</span>(<span class=\"string\">'5'</span>)</span><br><span class=\"line\">console.log([...set1])\t<span class=\"comment\">// [5, \"5\"]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Set 实例属性</p>\n<ul>\n<li><p>constructor： 构造函数</p>\n</li>\n<li><p>size：元素数量</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let <span class=\"built_in\">set</span> = <span class=\"built_in\">new</span> Set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"built_in\">set</span>.<span class=\"built_in\">length</span>)<span class=\"comment\">\t// undefined</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(<span class=\"built_in\">set</span>.size)<span class=\"comment\">\t// 3</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Set 实例方法</p>\n<ul>\n<li><p>操作方法</p>\n<ul>\n<li><p>add(value)：新增，相当于 array里的push</p>\n</li>\n<li><p>delete(value)：存在即删除集合中value</p>\n</li>\n<li><p>has(value)：判断集合中是否存在 value</p>\n</li>\n<li><p>clear()：清空集合</p>\n<hr>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> Set()</span><br><span class=\"line\"><span class=\"keyword\">set</span>.<span class=\"built_in\">add</span>(<span class=\"number\">1</span>).<span class=\"built_in\">add</span>(<span class=\"number\">2</span>).<span class=\"built_in\">add</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span>.<span class=\"built_in\">has</span>(<span class=\"number\">1</span>)\t// true</span><br><span class=\"line\"><span class=\"keyword\">set</span>.<span class=\"built_in\">has</span>(<span class=\"number\">3</span>)\t// false</span><br><span class=\"line\"><span class=\"keyword\">set</span>.<span class=\"keyword\">delete</span>(<span class=\"number\">1</span>)\t</span><br><span class=\"line\"><span class=\"keyword\">set</span>.<span class=\"built_in\">has</span>(<span class=\"number\">1</span>)\t// false</span><br></pre></td></tr></table></figure>\n\n<p><code>Array.from</code> 方法可以将 Set 结构转为数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"keyword\">const</span> array = <span class=\"built_in\">Array</span>.from(items)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array)\t<span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [...items]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr)\t<span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>遍历方法（遍历顺序为插入顺序）</p>\n<ul>\n<li><p>keys()：返回一个包含集合中所有键的迭代器</p>\n</li>\n<li><p>values()：返回一个包含集合中所有值得迭代器</p>\n</li>\n<li><p>entries()：返回一个包含Set对象中所有元素得键值对迭代器</p>\n</li>\n<li><p>forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，<strong>没有返回值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = new Set([1, 2, 3])</span><br><span class=\"line\">console.log(<span class=\"keyword\">set</span>.keys())\t// SetIterator &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">set</span>.values())\t// SetIterator &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">set</span>.entries())\t// SetIterator &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> <span class=\"keyword\">set</span>.keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;\t<span class=\"comment\">// 1\t2\t 3</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> <span class=\"keyword\">set</span>.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;\t<span class=\"comment\">// [1, 1]\t[2, 2]\t[3, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span>.forEach((value, key) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key + <span class=\"string\">' : '</span> + value)</span><br><span class=\"line\">&#125;)\t<span class=\"comment\">// 1 : 1\t2 : 2\t3 : 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([...set])\t<span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<p>Set 可默认遍历，默认迭代器生成函数是 values() 方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Set</span>.prototype[<span class=\"built_in\">Symbol</span>.iterator] === <span class=\"built_in\">Set</span>.prototype.values\t<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>所以， Set可以使用 map、filter 方法</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let <span class=\"built_in\">set</span> = <span class=\"built_in\">new</span> Set([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"built_in\">set</span> = <span class=\"built_in\">new</span> Set([...<span class=\"built_in\">set</span>].map(<span class=\"keyword\">item</span> =&gt; <span class=\"keyword\">item</span> * <span class=\"number\">2</span>))</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([...<span class=\"built_in\">set</span>])<span class=\"comment\">\t// [2, 4, 6]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> = <span class=\"built_in\">new</span> Set([...<span class=\"built_in\">set</span>].<span class=\"built_in\">filter</span>(<span class=\"keyword\">item</span> =&gt; (<span class=\"keyword\">item</span> &gt;= <span class=\"number\">4</span>)))</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([...<span class=\"built_in\">set</span>])<span class=\"comment\">\t//[4, 6]</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"keyword\">let</span> set2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> intersect = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set1].filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> set2.has(value)))</span><br><span class=\"line\"><span class=\"keyword\">let</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set1, ...set2])</span><br><span class=\"line\"><span class=\"keyword\">let</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set1].filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> !set2.has(value)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(intersect)\t<span class=\"comment\">// Set &#123;2, 3&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(union)\t\t<span class=\"comment\">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(difference)\t<span class=\"comment\">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-WeakSet\"><a href=\"#2-WeakSet\" class=\"headerlink\" title=\"2. WeakSet\"></a>2. WeakSet</h3><p>WeakSet 对象允许你将<strong>弱引用对象</strong>储存在一个集合中</p>\n<p>WeakSet 与 Set 的区别：</p>\n<ul>\n<li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li>\n<li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li>\n</ul>\n<p>属性：</p>\n<ul>\n<li><p>constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = <span class=\"string\">[[1, 2], [3, 4]]</span></span><br><span class=\"line\">const weakset = new WeakSet(arr)</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(weakset)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><a href=\"https://user-images.githubusercontent.com/19721451/54000884-27290900-4184-11e9-92f0-4d19ac6d080b.png\" target=\"_blank\" rel=\"noopener\"><img src=\"assets/54000884-27290900-4184-11e9-92f0-4d19ac6d080b.png\" alt=\"2019-03-08 9 24 34\"></a></p>\n<p>方法：</p>\n<ul>\n<li>add(value)：在WeakSet 对象中添加一个元素value</li>\n<li>has(value)：判断 WeakSet 对象中是否包含value</li>\n<li>delete(value)：删除元素 value</li>\n<li>clear()：清空所有元素，<strong>注意该方法已废弃</strong></li>\n</ul>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var <span class=\"keyword\">ws</span> = <span class=\"keyword\">new</span> WeakSet()</span><br><span class=\"line\">var obj = &#123;&#125;</span><br><span class=\"line\">var foo = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ws</span>.<span class=\"built_in\">add</span>(window)</span><br><span class=\"line\"><span class=\"keyword\">ws</span>.<span class=\"built_in\">add</span>(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ws</span>.<span class=\"built_in\">has</span>(window)\t// true</span><br><span class=\"line\"><span class=\"keyword\">ws</span>.<span class=\"built_in\">has</span>(foo)\t// false</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ws</span>.<span class=\"keyword\">delete</span>(window)\t// true</span><br><span class=\"line\"><span class=\"keyword\">ws</span>.<span class=\"built_in\">has</span>(window)\t// false</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-字典（Map）\"><a href=\"#3-字典（Map）\" class=\"headerlink\" title=\"3. 字典（Map）\"></a>3. 字典（Map）</h3><p>集合 与 字典 的区别：</p>\n<ul>\n<li>共同点：集合、字典 可以储存不重复的值</li>\n<li>不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存</li>\n</ul>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> o = &#123;p: <span class=\"string\">'haha'</span>&#125;</span><br><span class=\"line\">m.<span class=\"keyword\">set</span>(o, <span class=\"string\">'content'</span>)</span><br><span class=\"line\">m.<span class=\"keyword\">get</span>(o)\t<span class=\"comment\">// content</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.has(o)\t<span class=\"comment\">// true</span></span><br><span class=\"line\">m.delete(o)\t<span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(o)\t<span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构</strong>都可以当作<code>Map</code>构造函数的参数，例如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([</span><br><span class=\"line\">  [<span class=\"string\">'foo'</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"string\">'bar'</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> m1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(<span class=\"keyword\">set</span>);</span><br><span class=\"line\">m1.<span class=\"keyword\">get</span>(<span class=\"string\">'foo'</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> m2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">'baz'</span>, <span class=\"number\">3</span>]]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> m3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(m2);</span><br><span class=\"line\">m3.<span class=\"keyword\">get</span>(<span class=\"string\">'baz'</span>) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().<span class=\"keyword\">get</span>(<span class=\"string\">'asfddfsasadf'</span>)</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">set</span>([<span class=\"string\">'a'</span>], <span class=\"number\">555</span>);</span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>([<span class=\"string\">'a'</span>]) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>\n<p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>\n<p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> Map();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">set</span>(<span class=\"number\">-0</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(+<span class=\"number\">0</span>) <span class=\"comment\">// 123</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">set</span>(<span class=\"keyword\">true</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">set</span>(<span class=\"string\">'true'</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(<span class=\"keyword\">true</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">set</span>(undefined, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">set</span>(<span class=\"keyword\">null</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(undefined) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">set</span>(NaN, <span class=\"number\">123</span>);</span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">get</span>(NaN) <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<p>Map 的属性及方法</p>\n<p>属性：</p>\n<ul>\n<li><p>constructor：构造函数</p>\n</li>\n<li><p>size：返回字典中所包含的元素个数</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> Map([</span><br><span class=\"line\">  [<span class=\"string\">'name'</span>, <span class=\"string\">'An'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'des'</span>, <span class=\"string\">'JS'</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span>.<span class=\"built_in\">size</span> <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>操作方法：</p>\n<ul>\n<li>set(key, value)：向字典中添加新元素</li>\n<li>get(key)：通过键查找特定的数值并返回</li>\n<li>has(key)：判断字典中是否存在键key</li>\n<li>delete(key)：通过键 key 从字典中移除对应的数据</li>\n<li>clear()：将这个字典中的所有元素删除</li>\n</ul>\n<p>遍历方法</p>\n<ul>\n<li>Keys()：将字典中包含的所有键名以迭代器形式返回</li>\n<li>values()：将字典中包含的所有数值以迭代器形式返回</li>\n<li>entries()：返回所有成员的迭代器</li>\n<li>forEach()：遍历字典的所有成员</li>\n</ul>\n<figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = new Map([</span><br><span class=\"line\">            [<span class=\"string\">'name'</span>, <span class=\"string\">'An'</span>],</span><br><span class=\"line\">            [<span class=\"string\">'des'</span>, <span class=\"string\">'JS'</span>]</span><br><span class=\"line\">        ])<span class=\"comment\">;</span></span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(map.entries())\t// MapIterator &#123;<span class=\"string\">\"name\"</span> =&gt; <span class=\"string\">\"An\"</span>, <span class=\"string\">\"des\"</span> =&gt; <span class=\"string\">\"JS\"</span>&#125;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(map.keys()) // MapIterator &#123;<span class=\"string\">\"name\"</span>, <span class=\"string\">\"des\"</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">map</span>[Symbol.iterator] === <span class=\"built_in\">map</span>.entries</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p>\n<p>对于 forEach ，看一个例子</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reporter = &#123;</span><br><span class=\"line\">  report: <span class=\"keyword\">function</span><span class=\"built_in\">(key</span>, <span class=\"keyword\">value</span>) &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">\"Key: %s, Value: %s\"</span>,<span class=\"built_in\"> key</span>, <span class=\"keyword\">value</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">map</span> = new Map([</span><br><span class=\"line\">    [<span class=\"string\">'name'</span>, <span class=\"string\">'An'</span>],</span><br><span class=\"line\">    [<span class=\"string\">'des'</span>, <span class=\"string\">'JS'</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"keyword\">map</span>.forEach(<span class=\"keyword\">function</span>(<span class=\"keyword\">value</span>,<span class=\"built_in\"> key</span>, <span class=\"keyword\">map</span>) &#123;</span><br><span class=\"line\">  this.report<span class=\"built_in\">(key</span>, <span class=\"keyword\">value</span>);</span><br><span class=\"line\">&#125;, reporter);</span><br><span class=\"line\">// Key:<span class=\"built_in\"> name</span>, Value: An</span><br><span class=\"line\">// Key: des, Value: JS</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中， forEach 方法的回调函数的 this，就指向 reporter</p>\n<p><strong>与其他数据结构的相互转换</strong></p>\n<ol>\n<li><p>Map 转 Array</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map(<span class=\"string\">[[1, 1], [2, 2], [3, 3]]</span>)</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>([...map])\t// <span class=\"string\">[[1, 1], [2, 2], [3, 3]]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Array 转 Map</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map([[<span class=\"number\">1</span>, <span class=\"number\">1</span>], [<span class=\"number\">2</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">3</span>]])</span><br><span class=\"line\">console.log(map)\t<span class=\"comment\">// Map &#123;1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map 转 Object</p>\n<p>因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> mapToObj(<span class=\"keyword\">map</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> obj = Object.create(null)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> <span class=\"built_in\">[key</span>, <span class=\"keyword\">value</span>] <span class=\"keyword\">of</span> <span class=\"keyword\">map</span>) &#123;</span><br><span class=\"line\">        obj<span class=\"built_in\">[key</span>] = <span class=\"keyword\">value</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const <span class=\"keyword\">map</span> = new Map().set(<span class=\"string\">'name'</span>, <span class=\"string\">'An'</span>).set(<span class=\"string\">'des'</span>, <span class=\"string\">'JS'</span>)</span><br><span class=\"line\">mapToObj(<span class=\"keyword\">map</span>)  // <span class=\"built_in\">&#123;name</span>: <span class=\"string\">\"An\"</span>, des: <span class=\"string\">\"JS\"</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object 转 Map</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">objToMap</span><span class=\"params\">(obj)</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">map</span> = <span class=\"keyword\">new</span> Map()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key of Object.<span class=\"built_in\">keys</span>(obj)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">map</span>.<span class=\"keyword\">set</span>(key, obj[key])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">map</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">objToMap(&#123;<span class=\"string\">'name'</span>: <span class=\"string\">'An'</span>, <span class=\"string\">'des'</span>: <span class=\"string\">'JS'</span>&#125;) // Map &#123;<span class=\"string\">\"name\"</span> =&gt; <span class=\"string\">\"An\"</span>, <span class=\"string\">\"des\"</span> =&gt; <span class=\"string\">\"JS\"</span>&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map 转 JSON</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapToJson</span><span class=\"params\">(map)</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> JSON.stringify([...<span class=\"keyword\">map</span>])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">map</span> = <span class=\"keyword\">new</span> Map().<span class=\"keyword\">set</span>(<span class=\"string\">'name'</span>, <span class=\"string\">'An'</span>).<span class=\"keyword\">set</span>(<span class=\"string\">'des'</span>, <span class=\"string\">'JS'</span>)</span><br><span class=\"line\">mapToJson(<span class=\"keyword\">map</span>)\t// [[<span class=\"string\">\"name\"</span>,<span class=\"string\">\"An\"</span>],[<span class=\"string\">\"des\"</span>,<span class=\"string\">\"JS\"</span>]]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>JSON 转 Map</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title\">jsonToStrMap</span>(jsonStr) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"type\">objToMap(JSON.parse(jsonStr))</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToStrMap('&#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"An\"</span>, <span class=\"string\">\"des\"</span>: <span class=\"string\">\"JS\"</span>&#125;') // Map &#123;<span class=\"string\">\"name\"</span> =&gt; <span class=\"string\">\"An\"</span>, <span class=\"string\">\"des\"</span> =&gt; <span class=\"string\">\"JS\"</span>&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"4-WeakMap\"><a href=\"#4-WeakMap\" class=\"headerlink\" title=\"4. WeakMap\"></a>4. WeakMap</h3><p>WeakMap 对象是一组键值对的集合，其中的<strong>键是弱引用对象，而值可以是任意</strong>。</p>\n<p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p>\n<p>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。</p>\n<p>属性：</p>\n<ul>\n<li>constructor：构造函数</li>\n</ul>\n<p>方法：</p>\n<ul>\n<li>has(key)：判断是否有 key 关联对象</li>\n<li>get(key)：返回key关联对象（没有则则返回 undefined）</li>\n<li>set(key)：设置一组key关联对象</li>\n<li>delete(key)：移除 key 的关联对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'logo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> myWeakmap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">myWeakmap.set(myElement, &#123;<span class=\"attr\">timesClicked</span>: <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myElement.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> logoData = myWeakmap.get(myElement);</span><br><span class=\"line\">  logoData.timesClicked++;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h3><ul>\n<li>Set<ul>\n<li>成员唯一、无序且不重复</li>\n<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）</li>\n<li>可以遍历，方法有：add、delete、has</li>\n</ul>\n</li>\n<li>WeakSet<ul>\n<li>成员都是对象</li>\n<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏</li>\n<li>不能遍历，方法有add、delete、has</li>\n</ul>\n</li>\n<li>Map<ul>\n<li>本质上是键值对的集合，类似集合</li>\n<li>可以遍历，方法很多可以跟各种数据格式转换</li>\n</ul>\n</li>\n<li>WeakMap<ul>\n<li>只接受对象作为键名（null除外），不接受其他类型的值作为键名</li>\n<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的</li>\n<li>不能遍历，方法有get、set、has、delete</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-扩展：Object与Set、Map\"><a href=\"#6-扩展：Object与Set、Map\" class=\"headerlink\" title=\"6. 扩展：Object与Set、Map\"></a>6. 扩展：Object与Set、Map</h3><ol>\n<li><p>Object 与 Set</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> properties1 = &#123;</span><br><span class=\"line\">    <span class=\"string\">'width'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'height'</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(properties1[<span class=\"string\">'width'</span>]? <span class=\"keyword\">true</span>: <span class=\"keyword\">false</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Set</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> properties2 = <span class=\"keyword\">new</span> Set()</span><br><span class=\"line\">properties2.<span class=\"built_in\">add</span>(<span class=\"string\">'width'</span>)</span><br><span class=\"line\">properties2.<span class=\"built_in\">add</span>(<span class=\"string\">'height'</span>)</span><br><span class=\"line\">console.<span class=\"built_in\">log</span>(properties2.has(<span class=\"string\">'width'</span>)) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object 与 Map</p>\n</li>\n</ol>\n<p>JS 中的对象（Object），本质上是键值对的集合（hash 结构）</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">data</span> = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> element = document.getElementsByClassName(<span class=\"string\">'App'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">data</span>[element] = <span class=\"string\">'metadata'</span>;</span><br><span class=\"line\">console.log(<span class=\"keyword\">data</span>[<span class=\"string\">'[object HTMLCollection]'</span>]) <span class=\"comment\">// \"metadata\"</span></span><br></pre></td></tr></table></figure>\n\n<p>但当以一个DOM节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 <strong>字符串-值</strong> 对应，Map则提供了 <strong>值-值</strong> 的对应</p>\n","categories":["FrontEnd"],"tags":["JavaScript"]},{"title":"setTimeout、Promise、Async/Await 的区别","url":"https://xivier.github.io/2019/05/01/setTimeout、Promise、Async和Await的区别/","content":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>总结一下 setTimeout、Promise、Async/Await 的区别</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>我觉得这题主要是考察这三者在事件循环中的区别，事件循环中分为宏任务队列和微任务队列。</p>\n<p>其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行；</p>\n<p>promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行；async函数表示函数里面可能会有异步方法，await后面跟一个表达式，async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行。</p>\n<p>具体看看吧</p>\n<h4 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>)\t<span class=\"comment\">//1. 打印 script start</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'settimeout'</span>)\t<span class=\"comment\">// 4. 打印 settimeout</span></span><br><span class=\"line\">&#125;)\t<span class=\"comment\">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>)\t<span class=\"comment\">//3. 打印 script start</span></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序：script start-&gt;script end-&gt;settimeout</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>)</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1 end'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'settimeout'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span></span><br></pre></td></tr></table></figure>\n\n<p>当JS主线程执行到Promise对象时，</p>\n<ul>\n<li>promise1.then() 的回调就是一个 task</li>\n<li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>\n<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>\n<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>\n</ul>\n<h4 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 start'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'async1 end'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'async2'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\">async1();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure>\n\n<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>\n<p>举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(func1())</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://camo.githubusercontent.com/127fb6994c3e219bae33573cc46aab7f97b7367b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303133313137343431333536322e706e67\" target=\"_blank\" rel=\"noopener\"><img src=\"assets/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139303133313137343431333536322e706e67.png\" alt=\"在这里插入图片描述\"></a><br>很显然，func1的运行结果其实就是一个Promise对象。因此我们也可以使用then来处理后续逻辑。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func1().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);  <span class=\"comment\">// 30</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p>\n","categories":["FrontEnd"],"tags":["JavaScript"]},{"title":"关于map问题","url":"https://xivier.github.io/2019/04/22/map(parseInt)/","content":"<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>[‘1’, ‘2’, ‘3’].map(parseInt)结果是什么？为什么？</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是<strong>真正的答案是[1, NaN, NaN]</strong>。</p>\n<ul>\n<li>首先让我们回顾一下，map函数的第一个参数callback：</li>\n</ul>\n<p><code>var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])</code><br>这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。</p>\n<ul>\n<li>而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。<br><code>parseInt(string, radix)</code><br>接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。</li>\n<li>了解这两个函数后，我们可以模拟一下运行情况</li>\n</ul>\n<ol>\n<li>parseInt(‘1’, 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1</li>\n<li>parseInt(‘2’, 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</li>\n<li>parseInt(‘3’, 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN</li>\n</ol>\n<ul>\n<li>map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>主要要搞清楚传入的参数，map对数组的每个元素通过回调函数进行映射，第一个参数是该元素，第二个参数是该元素的索引，所以这两个参数传递给map中的回调函数。</p>\n<p>一般我们都是在map中自定义回调函数，然后对数组元素进行操作，这里是使用 parseInt 当做回调函数，parseInt 的第一个参数是被处理的值，第二个表示基数，将 k 进制数转成 10 进制数的，所以 map 时每次的 index 都会当做基数传入。</p>\n","categories":["FrontEnd"],"tags":["JavaScript"]},{"title":"about","url":"https://xivier.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://xivier.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://xivier.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"https://xivier.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://xivier.github.io/tag/index.html","content":"","categories":[],"tags":[]}]